import { 
  VULNERABILITY_CATEGORIES, 
  VulnerabilityCategory,
  getVulnerabilityCategoriesByType,
  generateDetectionPrompt,
  mapFindingToStandards
} from '../../lib/vulnerabilityCategories';

describe('vulnerabilityCategories', () => {
  describe('VULNERABILITY_CATEGORIES', () => {
    it('should contain expected vulnerability categories', () => {
      expect(VULNERABILITY_CATEGORIES).toBeDefined();
      expect(Array.isArray(VULNERABILITY_CATEGORIES)).toBe(true);
      expect(VULNERABILITY_CATEGORIES.length).toBeGreaterThan(0);

      // Check that all required categories are present
      const categoryIds = VULNERABILITY_CATEGORIES.map(cat => cat.id);
      const expectedCategories = [
        'reentrancy',
        'integer_overflow',
        'unchecked_calls',
        'unprotected_withdrawal',
        'tx_origin_auth',
        'inefficient_loops',
        'redundant_computations',
        'suboptimal_data_structures',
        'missing_function_modifiers',
        'unused_code',
        'missing_error_messages',
        'naming_conventions',
        'missing_documentation'
      ];

      expectedCategories.forEach(expected => {
        expect(categoryIds).toContain(expected);
      });
    });

    it('should have valid VulnerabilityCategory interface for each category', () => {
      VULNERABILITY_CATEGORIES.forEach((category, index) => {
        expect(category.id).toBeDefined();
        expect(typeof category.id).toBe('string');
        expect(category.id.length).toBeGreaterThan(0);

        expect(category.name).toBeDefined();
        expect(typeof category.name).toBe('string');
        expect(category.name.length).toBeGreaterThan(0);

        expect(category.description).toBeDefined();
        expect(typeof category.description).toBe('string');
        expect(category.description.length).toBeGreaterThan(0);

        expect(Array.isArray(category.swc_ids)).toBe(true);
        expect(Array.isArray(category.cwe_ids)).toBe(true);
        expect(Array.isArray(category.severity_range)).toBe(true);
        expect(Array.isArray(category.detection_patterns)).toBe(true);
        expect(Array.isArray(category.examples)).toBe(true);

        // Check severity range contains valid values
        const validSeverities = ['low', 'medium', 'high', 'critical'];
        category.severity_range.forEach(severity => {
          expect(validSeverities).toContain(severity);
        });
      });
    });

    it('should have security categories with proper SWC IDs', () => {
      const securityCategories = VULNERABILITY_CATEGORIES.filter(cat => 
        ['reentrancy', 'integer_overflow', 'unchecked_calls', 'unprotected_withdrawal', 'tx_origin_auth'].includes(cat.id)
      );

      securityCategories.forEach(category => {
        if (category.swc_ids.length > 0) {
          category.swc_ids.forEach(swc => {
            expect(swc).toMatch(/^SWC-\d+$/);
          });
        }
      });
    });

    it('should have categories with proper CWE IDs', () => {
      VULNERABILITY_CATEGORIES.forEach(category => {
        category.cwe_ids.forEach(cwe => {
          expect(cwe).toMatch(/^CWE-\d+$/);
        });
      });
    });

    it('should have non-empty detection patterns for each category', () => {
      VULNERABILITY_CATEGORIES.forEach(category => {
        expect(category.detection_patterns.length).toBeGreaterThan(0);
        category.detection_patterns.forEach(pattern => {
          expect(typeof pattern).toBe('string');
          expect(pattern.length).toBeGreaterThan(0);
        });
      });
    });
  });

  describe('getVulnerabilityCategoriesByType', () => {
    it('should return categories grouped by type', () => {
      const categoriesByType = getVulnerabilityCategoriesByType();

      expect(categoriesByType).toHaveProperty('security');
      expect(categoriesByType).toHaveProperty('gas_optimization');
      expect(categoriesByType).toHaveProperty('code_quality');

      expect(Array.isArray(categoriesByType.security)).toBe(true);
      expect(Array.isArray(categoriesByType.gas_optimization)).toBe(true);
      expect(Array.isArray(categoriesByType.code_quality)).toBe(true);
    });

    it('should classify security categories correctly', () => {
      const { security } = getVulnerabilityCategoriesByType();
      const securityIds = security.map(cat => cat.id);

      expect(securityIds).toContain('reentrancy');
      expect(securityIds).toContain('integer_overflow');
      expect(securityIds).toContain('unchecked_calls');
      expect(securityIds).toContain('unprotected_withdrawal');
      expect(securityIds).toContain('tx_origin_auth');

      // Should not contain gas optimization categories
      expect(securityIds).not.toContain('inefficient_loops');
      expect(securityIds).not.toContain('unused_code');
    });

    it('should classify gas optimization categories correctly', () => {
      const { gas_optimization } = getVulnerabilityCategoriesByType();
      const gasOptIds = gas_optimization.map(cat => cat.id);

      expect(gasOptIds).toContain('inefficient_loops');
      expect(gasOptIds).toContain('redundant_computations');
      expect(gasOptIds).toContain('suboptimal_data_structures');
      expect(gasOptIds).toContain('missing_function_modifiers');

      // Should not contain security categories
      expect(gasOptIds).not.toContain('reentrancy');
      expect(gasOptIds).not.toContain('unchecked_calls');
    });

    it('should classify code quality categories correctly', () => {
      const { code_quality } = getVulnerabilityCategoriesByType();
      const codeQualityIds = code_quality.map(cat => cat.id);

      expect(codeQualityIds).toContain('unused_code');
      expect(codeQualityIds).toContain('missing_error_messages');
      expect(codeQualityIds).toContain('naming_conventions');
      expect(codeQualityIds).toContain('missing_documentation');

      // Should not contain security or gas optimization categories
      expect(codeQualityIds).not.toContain('reentrancy');
      expect(codeQualityIds).not.toContain('inefficient_loops');
    });

    it('should not have overlapping categories between types', () => {
      const { security, gas_optimization, code_quality } = getVulnerabilityCategoriesByType();
      
      const securityIds = security.map(cat => cat.id);
      const gasOptIds = gas_optimization.map(cat => cat.id);
      const codeQualityIds = code_quality.map(cat => cat.id);

      // Check no overlaps
      securityIds.forEach(id => {
        expect(gasOptIds).not.toContain(id);
        expect(codeQualityIds).not.toContain(id);
      });

      gasOptIds.forEach(id => {
        expect(securityIds).not.toContain(id);
        expect(codeQualityIds).not.toContain(id);
      });

      codeQualityIds.forEach(id => {
        expect(securityIds).not.toContain(id);
        expect(gasOptIds).not.toContain(id);
      });
    });
  });

  describe('generateDetectionPrompt', () => {
    it('should generate a comprehensive detection prompt', () => {
      const prompt = generateDetectionPrompt();

      expect(typeof prompt).toBe('string');
      expect(prompt.length).toBeGreaterThan(100);

      // Should include all major sections
      expect(prompt).toContain('COMPREHENSIVE VULNERABILITY DETECTION CATEGORIES');
      expect(prompt).toContain('SECURITY ISSUES (Priority: High)');
      expect(prompt).toContain('GAS OPTIMIZATION ISSUES (Priority: Medium)');
      expect(prompt).toContain('CODE QUALITY ISSUES (Priority: Low)');
    });

    it('should include security categories in the prompt', () => {
      const prompt = generateDetectionPrompt();

      expect(prompt).toContain('Reentrancy Vulnerabilities');
      expect(prompt).toContain('Integer Overflow/Underflow');
      expect(prompt).toContain('Unchecked Call Return Values');
      expect(prompt).toContain('Unprotected Ether Withdrawal');
      expect(prompt).toContain('Authorization through tx.origin');
    });

    it('should include gas optimization categories in the prompt', () => {
      const prompt = generateDetectionPrompt();

      expect(prompt).toContain('Inefficient Loops');
      expect(prompt).toContain('Redundant Computations');
      expect(prompt).toContain('Suboptimal Data Structures');
      expect(prompt).toContain('Missing View/Pure Function Modifiers');
    });

    it('should include code quality categories in the prompt', () => {
      const prompt = generateDetectionPrompt();

      expect(prompt).toContain('Unused Variables and Functions');
      expect(prompt).toContain('Missing Error Messages');
      expect(prompt).toContain('Inconsistent Naming Conventions');
      expect(prompt).toContain('Lack of Documentation');
    });

    it('should include SWC IDs for security categories', () => {
      const prompt = generateDetectionPrompt();

      expect(prompt).toContain('SWC-107'); // Reentrancy
      expect(prompt).toContain('SWC-101'); // Integer overflow
      expect(prompt).toContain('SWC-104'); // Unchecked calls
      expect(prompt).toContain('SWC-105'); // Unprotected withdrawal
      expect(prompt).toContain('SWC-115'); // tx.origin
    });

    it('should include detection patterns for each category', () => {
      const prompt = generateDetectionPrompt();

      expect(prompt).toContain('external calls before state changes');
      expect(prompt).toContain('arithmetic operations without SafeMath');
      expect(prompt).toContain('call() without return value check');
      expect(prompt).toContain('withdrawal functions without access control');
      expect(prompt).toContain('require(tx.origin == owner)');
    });
  });

  describe('mapFindingToStandards', () => {
    it('should map category by ID to standards', () => {
      const result = mapFindingToStandards('reentrancy', 'External call vulnerability');

      expect(result.swc_id).toBe('SWC-107');
      expect(result.cwe_id).toBe('CWE-841');
    });

    it('should map category by name to standards', () => {
      const result = mapFindingToStandards('Reentrancy Vulnerabilities', 'External call issue');

      expect(result.swc_id).toBe('SWC-107');
      expect(result.cwe_id).toBe('CWE-841');
    });

    it('should handle category with spaces converted to underscores', () => {
      const result = mapFindingToStandards('integer overflow', 'Arithmetic issue');

      expect(result.swc_id).toBe('SWC-101');
      expect(result.cwe_id).toBe('CWE-190');
    });

    it('should handle case insensitive matching', () => {
      const result = mapFindingToStandards('REENTRANCY', 'External call issue');

      expect(result.swc_id).toBe('SWC-107');
      expect(result.cwe_id).toBe('CWE-841');
    });

    it('should return empty object for unknown category', () => {
      const result = mapFindingToStandards('unknown_category', 'Some description');

      expect(result.swc_id).toBeUndefined();
      expect(result.cwe_id).toBeUndefined();
    });

    it('should handle categories with multiple SWC/CWE IDs by returning the first', () => {
      const result = mapFindingToStandards('integer_overflow', 'Overflow issue');

      expect(result.swc_id).toBe('SWC-101');
      expect(result.cwe_id).toBe('CWE-190'); // Should be first CWE ID
    });

    it('should handle categories with no SWC/CWE IDs gracefully', () => {
      const result = mapFindingToStandards('redundant_computations', 'Gas optimization issue');

      expect(result.swc_id).toBeUndefined();
      expect(result.cwe_id).toBeUndefined();
    });

    it('should work with all security categories', () => {
      const securityCategories = [
        'reentrancy',
        'integer_overflow', 
        'unchecked_calls',
        'unprotected_withdrawal',
        'tx_origin_auth'
      ];

      securityCategories.forEach(categoryId => {
        const result = mapFindingToStandards(categoryId, 'Test description');
        expect(result.swc_id).toBeDefined();
        expect(result.swc_id).toMatch(/^SWC-\d+$/);
      });
    });
  });

  describe('Specific vulnerability category tests', () => {
    it('should have correct reentrancy category definition', () => {
      const reentrancy = VULNERABILITY_CATEGORIES.find(cat => cat.id === 'reentrancy');
      
      expect(reentrancy).toBeDefined();
      expect(reentrancy!.name).toBe('Reentrancy Vulnerabilities');
      expect(reentrancy!.swc_ids).toContain('SWC-107');
      expect(reentrancy!.cwe_ids).toContain('CWE-841');
      expect(reentrancy!.detection_patterns).toContain('external calls before state changes');
      expect(reentrancy!.severity_range).toEqual(expect.arrayContaining(['medium', 'high', 'critical']));
    });

    it('should have correct integer overflow category definition', () => {
      const overflow = VULNERABILITY_CATEGORIES.find(cat => cat.id === 'integer_overflow');
      
      expect(overflow).toBeDefined();
      expect(overflow!.name).toBe('Integer Overflow/Underflow');
      expect(overflow!.swc_ids).toContain('SWC-101');
      expect(overflow!.cwe_ids).toEqual(expect.arrayContaining(['CWE-190', 'CWE-191']));
      expect(overflow!.detection_patterns).toContain('arithmetic operations without SafeMath');
    });

    it('should have correct tx.origin category definition', () => {
      const txOrigin = VULNERABILITY_CATEGORIES.find(cat => cat.id === 'tx_origin_auth');
      
      expect(txOrigin).toBeDefined();
      expect(txOrigin!.name).toBe('Authorization through tx.origin');
      expect(txOrigin!.swc_ids).toContain('SWC-115');
      expect(txOrigin!.cwe_ids).toContain('CWE-346');
      expect(txOrigin!.detection_patterns).toContain('require(tx.origin == owner)');
      expect(txOrigin!.severity_range).toEqual(['medium', 'high']);
    });
  });

  describe('Edge cases and error handling', () => {
    it('should handle empty category string', () => {
      const result = mapFindingToStandards('', 'Empty category');
      expect(result).toEqual({});
    });

    it('should handle null/undefined category gracefully', () => {
      const result1 = mapFindingToStandards(null as any, 'Null category');
      const result2 = mapFindingToStandards(undefined as any, 'Undefined category');
      
      expect(result1).toEqual({});
      expect(result2).toEqual({});
    });

    it('should handle categories with extra whitespace', () => {
      const result = mapFindingToStandards('  reentrancy  ', 'Test description');
      expect(result.swc_id).toBe('SWC-107');
    });
  });
});