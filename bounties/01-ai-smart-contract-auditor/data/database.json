{
  "audit_reports": [
    {
      "id": "report_1753460622223_v064tk21q",
      "contract_address": "0x22f41abf77905f50df398f21213290597e7414dd",
      "report_json": "{\"findings\":[{\"id\":\"1\",\"category\":\"Reentrancy\",\"severity\":\"medium\",\"swc_id\":\"SWC-107\",\"cwe_id\":\"CWE-841\",\"title\":\"Potential Reentrancy Vulnerability in `transferFrom` Function\",\"description\":\"The `transferFrom` function in the `ERC20` contract does not follow the recommended Checks-Effects-Interactions pattern, which could lead to a reentrancy vulnerability. An attacker could repeatedly call the `transferFrom` function before the contract updates the allowance, potentially draining the victim's funds.\",\"lines\":[175,176,177,178,179,180,181],\"recommendation\":\"Implement the Checks-Effects-Interactions pattern by updating the allowance before executing the transfer. Additionally, consider using the OpenZeppelin ReentrancyGuard contract to protect against reentrancy attacks.\"},{\"id\":\"2\",\"category\":\"Access Control\",\"severity\":\"low\",\"swc_id\":\"SWC-105\",\"cwe_id\":\"CWE-284\",\"title\":\"Lack of Access Control in `burn` Function\",\"description\":\"The `burn` function in the `PPIToken` contract does not have any access control mechanism, allowing any user to burn tokens. This could lead to unintended token burning by malicious actors.\",\"lines\":[251],\"recommendation\":\"Implement access control in the `burn` function to ensure only authorized entities can burn tokens, such as by adding the `onlyOwner` modifier.\"},{\"id\":\"3\",\"category\":\"Integer Overflow/Underflow\",\"severity\":\"high\",\"swc_id\":\"SWC-101\",\"cwe_id\":\"CWE-190\",\"title\":\"Potential Integer Overflow in `_balances` Mapping\",\"description\":\"The `_balances` mapping in the `ERC20` contract is not protected against integer overflow/underflow, which could allow an attacker to manipulate the token balances. This could lead to unexpected token transfers or other unintended behavior.\",\"lines\":[47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174],\"recommendation\":\"Implement SafeMath or similar overflow/underflow protection mechanisms to ensure that arithmetic operations in the `_balances` mapping do not result in unexpected behavior.\"},{\"id\":\"4\",\"category\":\"Timestamp Dependence\",\"severity\":\"medium\",\"swc_id\":\"SWC-116\",\"cwe_id\":\"CWE-829\",\"title\":\"Potential Timestamp Dependence Vulnerability\",\"description\":\"The contract does not have any timestamp-dependent functionality, but it is important to be aware of potential timestamp manipulation attacks, where an attacker could exploit the block timestamp to their advantage. This could lead to issues such as unfair token distribution or other unintended consequences.\",\"lines\":[],\"recommendation\":\"Carefully review any timestamp-dependent functionality in the contract and consider adding appropriate safeguards, such as using the OpenZeppelin TimestampCounter contract or implementing a time-based mechanism that is not solely dependent on the block timestamp.\"}],\"summary\":{\"total\":4,\"critical\":0,\"high\":1,\"medium\":2,\"low\":1},\"generatedAt\":\"2025-07-25T16:23:42.207Z\"}",
      "report_markdown": "# Smart Contract Audit Report\n\n## Summary\n\n- **Total findings**: 4\n- **Critical**: 0 🔴\n- **High**: 1 🟠\n- **Medium**: 2 🟡\n- **Low**: 1 🟢\n\n---\n\n## Finding Details\n\n### 1. Potential Reentrancy Vulnerability in `transferFrom` Function 🟡\n\n**Severity**: MEDIUM\n\n**Description**: The `transferFrom` function in the `ERC20` contract does not follow the recommended Checks-Effects-Interactions pattern, which could lead to a reentrancy vulnerability. An attacker could repeatedly call the `transferFrom` function before the contract updates the allowance, potentially draining the victim's funds.\n\n**Recommendation**: Implement the Checks-Effects-Interactions pattern by updating the allowance before executing the transfer. Additionally, consider using the OpenZeppelin ReentrancyGuard contract to protect against reentrancy attacks.\n\n---\n\n### 2. Lack of Access Control in `burn` Function 🟢\n\n**Severity**: LOW\n\n**Description**: The `burn` function in the `PPIToken` contract does not have any access control mechanism, allowing any user to burn tokens. This could lead to unintended token burning by malicious actors.\n\n**Recommendation**: Implement access control in the `burn` function to ensure only authorized entities can burn tokens, such as by adding the `onlyOwner` modifier.\n\n---\n\n### 3. Potential Integer Overflow in `_balances` Mapping 🟠\n\n**Severity**: HIGH\n\n**Description**: The `_balances` mapping in the `ERC20` contract is not protected against integer overflow/underflow, which could allow an attacker to manipulate the token balances. This could lead to unexpected token transfers or other unintended behavior.\n\n**Recommendation**: Implement SafeMath or similar overflow/underflow protection mechanisms to ensure that arithmetic operations in the `_balances` mapping do not result in unexpected behavior.\n\n---\n\n### 4. Potential Timestamp Dependence Vulnerability 🟡\n\n**Severity**: MEDIUM\n\n**Description**: The contract does not have any timestamp-dependent functionality, but it is important to be aware of potential timestamp manipulation attacks, where an attacker could exploit the block timestamp to their advantage. This could lead to issues such as unfair token distribution or other unintended consequences.\n\n**Recommendation**: Carefully review any timestamp-dependent functionality in the contract and consider adding appropriate safeguards, such as using the OpenZeppelin TimestampCounter contract or implementing a time-based mechanism that is not solely dependent on the block timestamp.\n\n---\n\n\n*Report generated on 7/25/2025, 6:23:42 PM*\n",
      "findings_count": 4,
      "critical_findings": 0,
      "high_findings": 1,
      "medium_findings": 2,
      "low_findings": 1,
      "audit_status": "completed",
      "created_at": "2025-07-25T16:23:42.223Z",
      "updated_at": "2025-07-25T16:23:42.223Z",
      "processing_time_ms": 11098,
      "error_message": null,
      "audit_engine_version": "1.0.0",
      "static_analysis_tools": "[\"AI Analysis\"]"
    },
    {
      "id": "report_1753462305262_02rgcrgm3",
      "contract_address": "0x22f41abf77905f50df398f21213290597e7414dd",
      "report_json": "{\"findings\":[{\"id\":\"1\",\"category\":\"Reentrancy\",\"severity\":\"medium\",\"swc_id\":\"SWC-107\",\"cwe_id\":\"CWE-841\",\"title\":\"Potential Reentrancy Vulnerability in `transferFrom` Function\",\"description\":\"The `transferFrom` function in the `ERC20` contract does not follow the recommended Checks-Effects-Interactions pattern, which can lead to potential reentrancy vulnerabilities. The function first updates the allowance and then performs the token transfer, which could allow a malicious contract to repeatedly call the `transferFrom` function before the state is updated, potentially draining the contract's funds.\",\"lines\":[175,176,177,178,179,180,181],\"recommendation\":\"Implement the Checks-Effects-Interactions pattern by updating the allowance after the token transfer is complete. This can be done by moving the allowance update logic to the end of the function.\"},{\"id\":\"2\",\"category\":\"Integer Overflow/Underflow\",\"severity\":\"high\",\"swc_id\":\"SWC-101\",\"cwe_id\":\"CWE-190\",\"title\":\"Potential Integer Overflow in `_burn` Function\",\"description\":\"The `_burn` function in the `ERC20` contract does not perform any overflow/underflow checks on the `_balances[account]` and `_totalSupply` variables. This could allow an attacker to burn more tokens than they have, potentially leading to a denial of service or other unintended consequences.\",\"lines\":[259,260,261,262,263],\"recommendation\":\"Add overflow/underflow checks to the `_burn` function to ensure that the token balances and total supply cannot be manipulated in an unintended way.\"},{\"id\":\"3\",\"category\":\"Access Control\",\"severity\":\"medium\",\"swc_id\":\"SWC-105\",\"cwe_id\":\"CWE-284\",\"title\":\"Lack of Access Control in `burn` Function\",\"description\":\"The `burn` function in the `PPIToken` contract is not restricted to the token owner or any other authorized entity. This could allow any user to burn tokens, potentially leading to unintended consequences or loss of funds.\",\"lines\":[292],\"recommendation\":\"Restrict the `burn` function to only allow the token owner or other authorized entities to burn tokens. This can be done by adding an `onlyOwner` modifier or implementing a more granular access control mechanism.\"}],\"summary\":{\"total\":3,\"critical\":0,\"high\":1,\"medium\":2,\"low\":0},\"generatedAt\":\"2025-07-25T16:51:45.244Z\"}",
      "report_markdown": "# Smart Contract Audit Report\n\n## Summary\n\n- **Total findings**: 3\n- **Critical**: 0 🔴\n- **High**: 1 🟠\n- **Medium**: 2 🟡\n- **Low**: 0 🟢\n\n---\n\n## Finding Details\n\n### 1. Potential Reentrancy Vulnerability in `transferFrom` Function 🟡\n\n**Severity**: MEDIUM\n\n**Description**: The `transferFrom` function in the `ERC20` contract does not follow the recommended Checks-Effects-Interactions pattern, which can lead to potential reentrancy vulnerabilities. The function first updates the allowance and then performs the token transfer, which could allow a malicious contract to repeatedly call the `transferFrom` function before the state is updated, potentially draining the contract's funds.\n\n**Recommendation**: Implement the Checks-Effects-Interactions pattern by updating the allowance after the token transfer is complete. This can be done by moving the allowance update logic to the end of the function.\n\n---\n\n### 2. Potential Integer Overflow in `_burn` Function 🟠\n\n**Severity**: HIGH\n\n**Description**: The `_burn` function in the `ERC20` contract does not perform any overflow/underflow checks on the `_balances[account]` and `_totalSupply` variables. This could allow an attacker to burn more tokens than they have, potentially leading to a denial of service or other unintended consequences.\n\n**Recommendation**: Add overflow/underflow checks to the `_burn` function to ensure that the token balances and total supply cannot be manipulated in an unintended way.\n\n---\n\n### 3. Lack of Access Control in `burn` Function 🟡\n\n**Severity**: MEDIUM\n\n**Description**: The `burn` function in the `PPIToken` contract is not restricted to the token owner or any other authorized entity. This could allow any user to burn tokens, potentially leading to unintended consequences or loss of funds.\n\n**Recommendation**: Restrict the `burn` function to only allow the token owner or other authorized entities to burn tokens. This can be done by adding an `onlyOwner` modifier or implementing a more granular access control mechanism.\n\n---\n\n\n*Report generated on 7/25/2025, 6:51:45 PM*\n",
      "findings_count": 3,
      "critical_findings": 0,
      "high_findings": 1,
      "medium_findings": 2,
      "low_findings": 0,
      "audit_status": "completed",
      "created_at": "2025-07-25T16:51:45.262Z",
      "updated_at": "2025-07-25T16:51:45.262Z",
      "processing_time_ms": 6520,
      "error_message": null,
      "audit_engine_version": "1.0.0",
      "static_analysis_tools": "[\"AI Analysis\"]"
    },
    {
      "id": "report_1753462752958_1zxhjr60w",
      "contract_address": "0x22f41abf77905f50df398f21213290597e7414dd",
      "report_json": "{\"findings\":[{\"id\":\"1\",\"category\":\"Reentrancy\",\"severity\":\"medium\",\"swc_id\":\"SWC-107\",\"cwe_id\":\"CWE-841\",\"title\":\"Potential Reentrancy Vulnerability in `transferFrom` Function\",\"description\":\"The `transferFrom` function in the `ERC20` contract does not follow the recommended Checks-Effects-Interactions pattern, which could lead to a reentrancy vulnerability. An attacker could repeatedly call the `transferFrom` function before the contract updates the allowance, potentially draining the victim's funds.\",\"lines\":[174,175,176,177,178,179,180,181],\"recommendation\":\"Implement the Checks-Effects-Interactions pattern by updating the allowance before executing the transfer. Additionally, consider using the OpenZeppelin ReentrancyGuard contract to protect against reentrancy attacks.\"},{\"id\":\"2\",\"category\":\"Access Control\",\"severity\":\"low\",\"swc_id\":\"SWC-105\",\"cwe_id\":\"CWE-284\",\"title\":\"Lack of Access Control in `burn` Function\",\"description\":\"The `burn` function in the `PPIToken` contract does not have any access control mechanism. Any user can call this function and burn tokens, which could lead to unintended token burning.\",\"lines\":[233],\"recommendation\":\"Implement access control in the `burn` function to ensure only authorized entities can burn tokens. For example, you could add a modifier to restrict access to the contract owner or a designated burner role.\"},{\"id\":\"3\",\"category\":\"Integer Overflow/Underflow\",\"severity\":\"high\",\"swc_id\":\"SWC-101\",\"cwe_id\":\"CWE-190\",\"title\":\"Potential Integer Overflow in `_transfer` Function\",\"description\":\"The `_transfer` function in the `ERC20` contract does not perform any overflow/underflow checks on the `_balances` mapping. An attacker could potentially exploit this to overflow or underflow the token balances, leading to unexpected behavior and potential loss of funds.\",\"lines\":[209,210,211,212],\"recommendation\":\"Implement overflow/underflow checks in the `_transfer` function using the OpenZeppelin SafeMath library or similar techniques to prevent integer overflow/underflow vulnerabilities.\"}],\"summary\":{\"total\":3,\"critical\":0,\"high\":1,\"medium\":1,\"low\":1},\"generatedAt\":\"2025-07-25T16:59:12.907Z\"}",
      "report_markdown": "# Smart Contract Audit Report\n\n## Summary\n\n- **Total findings**: 3\n- **Critical**: 0 🔴\n- **High**: 1 🟠\n- **Medium**: 1 🟡\n- **Low**: 1 🟢\n\n---\n\n## Finding Details\n\n### 1. Potential Reentrancy Vulnerability in `transferFrom` Function 🟡\n\n**Severity**: MEDIUM\n\n**Description**: The `transferFrom` function in the `ERC20` contract does not follow the recommended Checks-Effects-Interactions pattern, which could lead to a reentrancy vulnerability. An attacker could repeatedly call the `transferFrom` function before the contract updates the allowance, potentially draining the victim's funds.\n\n**Recommendation**: Implement the Checks-Effects-Interactions pattern by updating the allowance before executing the transfer. Additionally, consider using the OpenZeppelin ReentrancyGuard contract to protect against reentrancy attacks.\n\n---\n\n### 2. Lack of Access Control in `burn` Function 🟢\n\n**Severity**: LOW\n\n**Description**: The `burn` function in the `PPIToken` contract does not have any access control mechanism. Any user can call this function and burn tokens, which could lead to unintended token burning.\n\n**Recommendation**: Implement access control in the `burn` function to ensure only authorized entities can burn tokens. For example, you could add a modifier to restrict access to the contract owner or a designated burner role.\n\n---\n\n### 3. Potential Integer Overflow in `_transfer` Function 🟠\n\n**Severity**: HIGH\n\n**Description**: The `_transfer` function in the `ERC20` contract does not perform any overflow/underflow checks on the `_balances` mapping. An attacker could potentially exploit this to overflow or underflow the token balances, leading to unexpected behavior and potential loss of funds.\n\n**Recommendation**: Implement overflow/underflow checks in the `_transfer` function using the OpenZeppelin SafeMath library or similar techniques to prevent integer overflow/underflow vulnerabilities.\n\n---\n\n\n*Report generated on 7/25/2025, 6:59:12 PM*\n",
      "findings_count": 3,
      "critical_findings": 0,
      "high_findings": 1,
      "medium_findings": 1,
      "low_findings": 1,
      "audit_status": "completed",
      "created_at": "2025-07-25T16:59:12.958Z",
      "updated_at": "2025-07-25T16:59:12.958Z",
      "processing_time_ms": 5666,
      "error_message": null,
      "audit_engine_version": "1.0.0",
      "static_analysis_tools": "[\"AI Analysis\"]"
    },
    {
      "id": "report_1753465485276_ibrcd9to5",
      "contract_address": "0x22f41abf77905f50df398f21213290597e7414dd",
      "report_json": "{}",
      "report_markdown": "",
      "findings_count": 0,
      "critical_findings": 0,
      "high_findings": 0,
      "medium_findings": 0,
      "low_findings": 0,
      "audit_status": "failed",
      "created_at": "2025-07-25T17:44:45.276Z",
      "updated_at": "2025-07-25T17:44:45.276Z",
      "processing_time_ms": 12265,
      "error_message": "Failed to parse AI analysis response: Unexpected token 'a', ...\": [\n      all\n    ],\"... is not valid JSON",
      "audit_engine_version": "1.0.0",
      "static_analysis_tools": "[\"AI Analysis\"]"
    },
    {
      "id": "report_1753465656533_nbvk10mqb",
      "contract_address": "0x22f41abf77905f50df398f21213290597e7414dd",
      "report_json": "{\"findings\":[{\"id\":\"6ea553cf-4620-4ad4-8e8d-843485e28f43\",\"category\":\"Security Issue\",\"severity\":\"low\",\"title\":\"\\\"description\\\": \\\"Several require statements in the `ERC20` contract do not have custom error messages\",\"description\":\"\\\"description\\\": \\\"Several require statements in the `ERC20` contract do not have custom error messages, making it harder to debug issues and understand the reason for reverts.\\\",\",\"swc_id\":\"SWC-105\",\"cwe_id\":\"CWE-284\",\"recommendation\":\"Review and address this issue\"}],\"categorizedFindings\":{\"security\":[],\"gas_optimization\":[],\"code_quality\":[],\"other\":[{\"id\":\"6ea553cf-4620-4ad4-8e8d-843485e28f43\",\"category\":\"Security Issue\",\"severity\":\"low\",\"title\":\"\\\"description\\\": \\\"Several require statements in the `ERC20` contract do not have custom error messages\",\"description\":\"\\\"description\\\": \\\"Several require statements in the `ERC20` contract do not have custom error messages, making it harder to debug issues and understand the reason for reverts.\\\",\",\"swc_id\":\"SWC-105\",\"cwe_id\":\"CWE-284\",\"recommendation\":\"Review and address this issue\"}]},\"summary\":{\"total\":1,\"critical\":0,\"high\":0,\"medium\":0,\"low\":1,\"byCategory\":{\"security\":0,\"gas_optimization\":0,\"code_quality\":0,\"other\":1}},\"generatedAt\":\"2025-07-25T17:47:36.471Z\"}",
      "report_markdown": "# Smart Contract Audit Report\n\n## Executive Summary\n\n**Total Findings**: 1\n\n### Severity Distribution\n- **Critical**: 0 🔴\n- **High**: 0 🟠\n- **Medium**: 0 🟡\n- **Low**: 1 🟢\n\n### Category Distribution\n- **Security Issues**: 0 findings\n- **Gas Optimization**: 0 findings\n- **Code Quality**: 0 findings\n- **Other Issues**: 1 findings\n\n---\n\n## 🔍 Other Findings\n\nFound 1 issue in this category.\n\n### 1. \"description\": \"Several require statements in the `ERC20` contract do not have custom error messages 🟢\n\n**Category**: Security Issue  \n**Severity**: LOW\n\n**Description**: \"description\": \"Several require statements in the `ERC20` contract do not have custom error messages, making it harder to debug issues and understand the reason for reverts.\",\n\n**Standards**: SWC-105, CWE-284\n\n**💡 Recommendation**: Review and address this issue\n\n---\n\n\n*Report generated on 7/25/2025, 7:47:36 PM*\n",
      "findings_count": 1,
      "critical_findings": 0,
      "high_findings": 0,
      "medium_findings": 0,
      "low_findings": 1,
      "audit_status": "completed",
      "created_at": "2025-07-25T17:47:36.533Z",
      "updated_at": "2025-07-25T17:47:36.533Z",
      "processing_time_ms": 9738,
      "error_message": null,
      "audit_engine_version": "1.0.0",
      "static_analysis_tools": "[\"AI Analysis\"]"
    },
    {
      "id": "report_1753466521112_ied8c19sl",
      "contract_address": "0x22f41abf77905f50df398f21213290597e7414dd",
      "report_json": "{\"findings\":[{\"id\":\"a3f5b601-e9c7-4de1-a4fe-79d0a06aeaeb\",\"category\":\"Analysis Issue\",\"severity\":\"low\",\"title\":\"AI Response Parsing Error\",\"description\":\"The AI analysis completed but the response format could not be parsed properly. Manual review may be needed.\",\"recommendation\":\"Review the contract manually or try the analysis again\"}],\"categorizedFindings\":{\"security\":[],\"gas_optimization\":[],\"code_quality\":[],\"other\":[{\"id\":\"a3f5b601-e9c7-4de1-a4fe-79d0a06aeaeb\",\"category\":\"Analysis Issue\",\"severity\":\"low\",\"title\":\"AI Response Parsing Error\",\"description\":\"The AI analysis completed but the response format could not be parsed properly. Manual review may be needed.\",\"recommendation\":\"Review the contract manually or try the analysis again\"}]},\"summary\":{\"total\":1,\"critical\":0,\"high\":0,\"medium\":0,\"low\":1,\"byCategory\":{\"security\":0,\"gas_optimization\":0,\"code_quality\":0,\"other\":1}},\"generatedAt\":\"2025-07-25T18:02:01.068Z\"}",
      "report_markdown": "# Smart Contract Audit Report\n\n## Executive Summary\n\n**Total Findings**: 1\n\n### Severity Distribution\n- **Critical**: 0 🔴\n- **High**: 0 🟠\n- **Medium**: 0 🟡\n- **Low**: 1 🟢\n\n### Category Distribution\n- **Security Issues**: 0 findings\n- **Gas Optimization**: 0 findings\n- **Code Quality**: 0 findings\n- **Other Issues**: 1 findings\n\n---\n\n## 🔍 Other Findings\n\nFound 1 issue in this category.\n\n### 1. AI Response Parsing Error 🟢\n\n**Category**: Analysis Issue  \n**Severity**: LOW\n\n**Description**: The AI analysis completed but the response format could not be parsed properly. Manual review may be needed.\n\n**💡 Recommendation**: Review the contract manually or try the analysis again\n\n---\n\n\n*Report generated on 7/25/2025, 8:02:01 PM*\n",
      "findings_count": 1,
      "critical_findings": 0,
      "high_findings": 0,
      "medium_findings": 0,
      "low_findings": 1,
      "audit_status": "completed",
      "created_at": "2025-07-25T18:02:01.112Z",
      "updated_at": "2025-07-25T18:02:01.112Z",
      "processing_time_ms": 9765,
      "error_message": null,
      "audit_engine_version": "1.0.0",
      "static_analysis_tools": "[\"AI Analysis\"]"
    },
    {
      "id": "report_1753467883113_2lf40stm8",
      "contract_address": "0x22f41abf77905f50df398f21213290597e7414dd",
      "report_json": "{\"findings\":[{\"id\":\"335fef08-518b-4ffe-9c68-32f196bdbda2\",\"category\":\"Analysis Issue\",\"severity\":\"low\",\"title\":\"AI Response Parsing Error\",\"description\":\"The AI analysis completed but the response format could not be parsed properly. Manual review may be needed.\",\"recommendation\":\"Review the contract manually or try the analysis again\"}],\"categorizedFindings\":{\"security\":[],\"gas_optimization\":[],\"code_quality\":[],\"other\":[{\"id\":\"335fef08-518b-4ffe-9c68-32f196bdbda2\",\"category\":\"Analysis Issue\",\"severity\":\"low\",\"title\":\"AI Response Parsing Error\",\"description\":\"The AI analysis completed but the response format could not be parsed properly. Manual review may be needed.\",\"recommendation\":\"Review the contract manually or try the analysis again\"}]},\"summary\":{\"total\":1,\"critical\":0,\"high\":0,\"medium\":0,\"low\":1,\"byCategory\":{\"security\":0,\"gas_optimization\":0,\"code_quality\":0,\"other\":1}},\"generatedAt\":\"2025-07-25T18:24:43.051Z\"}",
      "report_markdown": "# Smart Contract Audit Report\n\n## Executive Summary\n\n**Total Findings**: 1\n\n### Severity Distribution\n- **Critical**: 0 🔴\n- **High**: 0 🟠\n- **Medium**: 0 🟡\n- **Low**: 1 🟢\n\n### Category Distribution\n- **Security Issues**: 0 findings\n- **Gas Optimization**: 0 findings\n- **Code Quality**: 0 findings\n- **Other Issues**: 1 findings\n\n---\n\n## 🔍 Other Findings\n\nFound 1 issue in this category.\n\n### 1. AI Response Parsing Error 🟢\n\n**Category**: Analysis Issue  \n**Severity**: LOW\n\n**Description**: The AI analysis completed but the response format could not be parsed properly. Manual review may be needed.\n\n**💡 Recommendation**: Review the contract manually or try the analysis again\n\n---\n\n\n*Report generated on 7/25/2025, 8:24:43 PM*\n",
      "findings_count": 1,
      "critical_findings": 0,
      "high_findings": 0,
      "medium_findings": 0,
      "low_findings": 1,
      "audit_status": "completed",
      "created_at": "2025-07-25T18:24:43.113Z",
      "updated_at": "2025-07-25T18:24:43.113Z",
      "processing_time_ms": 13363,
      "error_message": null,
      "audit_engine_version": "1.0.0",
      "static_analysis_tools": "[\"AI Analysis\"]"
    },
    {
      "id": "report_1753475314042_ute6ykmtx",
      "contract_address": "0x22f41abf77905f50df398f21213290597e7414dd",
      "report_json": "{\"findings\":[{\"id\":\"214f6ab7-36ce-46f0-a40f-01a2d7beaf9c\",\"category\":\"Analysis Issue\",\"severity\":\"low\",\"title\":\"AI Response Parsing Error\",\"description\":\"The AI analysis completed but the response format could not be parsed properly. Manual review may be needed.\",\"recommendation\":\"Review the contract manually or try the analysis again\"}],\"categorizedFindings\":{\"security\":[],\"gas_optimization\":[],\"code_quality\":[],\"other\":[{\"id\":\"214f6ab7-36ce-46f0-a40f-01a2d7beaf9c\",\"category\":\"Analysis Issue\",\"severity\":\"low\",\"title\":\"AI Response Parsing Error\",\"description\":\"The AI analysis completed but the response format could not be parsed properly. Manual review may be needed.\",\"recommendation\":\"Review the contract manually or try the analysis again\"}]},\"summary\":{\"total\":1,\"critical\":0,\"high\":0,\"medium\":0,\"low\":1,\"byCategory\":{\"security\":0,\"gas_optimization\":0,\"code_quality\":0,\"other\":1}},\"generatedAt\":\"2025-07-25T20:28:33.981Z\"}",
      "report_markdown": "# Smart Contract Audit Report\n\n## Executive Summary\n\n**Total Findings**: 1\n\n### Severity Distribution\n- **Critical**: 0 🔴\n- **High**: 0 🟠\n- **Medium**: 0 🟡\n- **Low**: 1 🟢\n\n### Category Distribution\n- **Security Issues**: 0 findings\n- **Gas Optimization**: 0 findings\n- **Code Quality**: 0 findings\n- **Other Issues**: 1 findings\n\n---\n\n## 🔍 Other Findings\n\nFound 1 issue in this category.\n\n### 1. AI Response Parsing Error 🟢\n\n**Category**: Analysis Issue  \n**Severity**: LOW\n\n**Description**: The AI analysis completed but the response format could not be parsed properly. Manual review may be needed.\n\n**💡 Recommendation**: Review the contract manually or try the analysis again\n\n---\n\n\n*Report generated on 7/25/2025, 10:28:33 PM*\n",
      "findings_count": 1,
      "critical_findings": 0,
      "high_findings": 0,
      "medium_findings": 0,
      "low_findings": 1,
      "audit_status": "completed",
      "created_at": "2025-07-25T20:28:34.042Z",
      "updated_at": "2025-07-25T20:28:34.042Z",
      "processing_time_ms": 8439,
      "error_message": null,
      "audit_engine_version": "1.0.0",
      "static_analysis_tools": "[\"AI Analysis\"]"
    },
    {
      "id": "report_1753477264090_e6c9o0g6t",
      "contract_address": "0x22f41abf77905f50df398f21213290597e7414dd",
      "report_json": "{\"findings\":[{\"id\":\"0888b994-8c65-45ca-af6f-e2a6f3cf1500\",\"category\":\"Analysis Issue\",\"severity\":\"low\",\"title\":\"AI Response Parsing Error\",\"description\":\"The AI analysis completed but the response format could not be parsed properly. Manual review may be needed.\",\"recommendation\":\"Review the contract manually or try the analysis again\"}],\"categorizedFindings\":{\"security\":[],\"gas_optimization\":[],\"code_quality\":[],\"other\":[{\"id\":\"0888b994-8c65-45ca-af6f-e2a6f3cf1500\",\"category\":\"Analysis Issue\",\"severity\":\"low\",\"title\":\"AI Response Parsing Error\",\"description\":\"The AI analysis completed but the response format could not be parsed properly. Manual review may be needed.\",\"recommendation\":\"Review the contract manually or try the analysis again\"}]},\"summary\":{\"total\":1,\"critical\":0,\"high\":0,\"medium\":0,\"low\":1,\"byCategory\":{\"security\":0,\"gas_optimization\":0,\"code_quality\":0,\"other\":1}},\"generatedAt\":\"2025-07-25T21:01:04.023Z\"}",
      "report_markdown": "# Smart Contract Audit Report\n\n## Executive Summary\n\n**Total Findings**: 1\n\n### Severity Distribution\n- **Critical**: 0 🔴\n- **High**: 0 🟠\n- **Medium**: 0 🟡\n- **Low**: 1 🟢\n\n### Category Distribution\n- **Security Issues**: 0 findings\n- **Gas Optimization**: 0 findings\n- **Code Quality**: 0 findings\n- **Other Issues**: 1 findings\n\n---\n\n## 🔍 Other Findings\n\nFound 1 issue in this category.\n\n### 1. AI Response Parsing Error 🟢\n\n**Category**: Analysis Issue  \n**Severity**: LOW\n\n**Description**: The AI analysis completed but the response format could not be parsed properly. Manual review may be needed.\n\n**💡 Recommendation**: Review the contract manually or try the analysis again\n\n---\n\n\n*Report generated on 7/25/2025, 11:01:04 PM*\n",
      "findings_count": 1,
      "critical_findings": 0,
      "high_findings": 0,
      "medium_findings": 0,
      "low_findings": 1,
      "audit_status": "completed",
      "created_at": "2025-07-25T21:01:04.090Z",
      "updated_at": "2025-07-25T21:01:04.090Z",
      "processing_time_ms": 10815,
      "error_message": null,
      "audit_engine_version": "1.0.0",
      "static_analysis_tools": "[\"AI Analysis\"]"
    },
    {
      "id": "report_1753481069806_fwvjge8ze",
      "contract_address": "0x22f41abf77905f50df398f21213290597e7414dd",
      "report_json": "{\"findings\":[{\"id\":\"a5c9b87f-5de6-4e58-8527-bd95c542f398\",\"category\":\"Security Issue\",\"severity\":\"low\",\"title\":\"\\\"description\\\": \\\"Several require statements in the `ERC20` contract do not have custom error messages\",\"description\":\"\\\"description\\\": \\\"Several require statements in the `ERC20` contract do not have custom error messages, which can make it harder to debug issues and understand the reason for the revert.\\\",\",\"swc_id\":\"SWC-105\",\"cwe_id\":\"CWE-105\",\"recommendation\":\"Review and address this issue\"}],\"categorizedFindings\":{\"security\":[],\"gas_optimization\":[],\"code_quality\":[],\"other\":[{\"id\":\"a5c9b87f-5de6-4e58-8527-bd95c542f398\",\"category\":\"Security Issue\",\"severity\":\"low\",\"title\":\"\\\"description\\\": \\\"Several require statements in the `ERC20` contract do not have custom error messages\",\"description\":\"\\\"description\\\": \\\"Several require statements in the `ERC20` contract do not have custom error messages, which can make it harder to debug issues and understand the reason for the revert.\\\",\",\"swc_id\":\"SWC-105\",\"cwe_id\":\"CWE-105\",\"recommendation\":\"Review and address this issue\"}]},\"summary\":{\"total\":1,\"critical\":0,\"high\":0,\"medium\":0,\"low\":1,\"byCategory\":{\"security\":0,\"gas_optimization\":0,\"code_quality\":0,\"other\":1}},\"generatedAt\":\"2025-07-25T22:04:29.695Z\"}",
      "report_markdown": "# Smart Contract Audit Report\n\n## Executive Summary\n\n**Total Findings**: 1\n\n### Severity Distribution\n- **Critical**: 0 🔴\n- **High**: 0 🟠\n- **Medium**: 0 🟡\n- **Low**: 1 🟢\n\n### Category Distribution\n- **Security Issues**: 0 findings\n- **Gas Optimization**: 0 findings\n- **Code Quality**: 0 findings\n- **Other Issues**: 1 findings\n\n---\n\n## 🔍 Other Findings\n\nFound 1 issue in this category.\n\n### 1. \"description\": \"Several require statements in the `ERC20` contract do not have custom error messages 🟢\n\n**Category**: Security Issue  \n**Severity**: LOW\n\n**Description**: \"description\": \"Several require statements in the `ERC20` contract do not have custom error messages, which can make it harder to debug issues and understand the reason for the revert.\",\n\n**Standards**: SWC-105, CWE-105\n\n**💡 Recommendation**: Review and address this issue\n\n---\n\n\n*Report generated on 7/26/2025, 12:04:29 AM*\n",
      "findings_count": 1,
      "critical_findings": 0,
      "high_findings": 0,
      "medium_findings": 0,
      "low_findings": 1,
      "audit_status": "completed",
      "created_at": "2025-07-25T22:04:29.806Z",
      "updated_at": "2025-07-25T22:04:29.806Z",
      "processing_time_ms": 10640,
      "error_message": null,
      "audit_engine_version": "1.0.0",
      "static_analysis_tools": "[\"AI Analysis\"]"
    },
    {
      "id": "report_1753481619260_gwj5az74v",
      "contract_address": "0x22f41abf77905f50df398f21213290597e7414dd",
      "report_json": "{\"findings\":[{\"id\":\"726ac4bb-e333-406c-a3f0-0e36776f2064\",\"category\":\"Analysis Issue\",\"severity\":\"low\",\"title\":\"AI Response Parsing Error\",\"description\":\"The AI analysis completed but the response format could not be parsed properly. Manual review may be needed.\",\"recommendation\":\"Review the contract manually or try the analysis again\"}],\"categorizedFindings\":{\"security\":[],\"gas_optimization\":[],\"code_quality\":[],\"other\":[{\"id\":\"726ac4bb-e333-406c-a3f0-0e36776f2064\",\"category\":\"Analysis Issue\",\"severity\":\"low\",\"title\":\"AI Response Parsing Error\",\"description\":\"The AI analysis completed but the response format could not be parsed properly. Manual review may be needed.\",\"recommendation\":\"Review the contract manually or try the analysis again\"}]},\"summary\":{\"total\":1,\"critical\":0,\"high\":0,\"medium\":0,\"low\":1,\"byCategory\":{\"security\":0,\"gas_optimization\":0,\"code_quality\":0,\"other\":1}},\"generatedAt\":\"2025-07-25T22:13:39.234Z\"}",
      "report_markdown": "# Smart Contract Audit Report\n\n## Executive Summary\n\n**Total Findings**: 1\n\n### Severity Distribution\n- **Critical**: 0 🔴\n- **High**: 0 🟠\n- **Medium**: 0 🟡\n- **Low**: 1 🟢\n\n### Category Distribution\n- **Security Issues**: 0 findings\n- **Gas Optimization**: 0 findings\n- **Code Quality**: 0 findings\n- **Other Issues**: 1 findings\n\n---\n\n## 🔍 Other Findings\n\nFound 1 issue in this category.\n\n### 1. AI Response Parsing Error 🟢\n\n**Category**: Analysis Issue  \n**Severity**: LOW\n\n**Description**: The AI analysis completed but the response format could not be parsed properly. Manual review may be needed.\n\n**💡 Recommendation**: Review the contract manually or try the analysis again\n\n---\n\n\n*Report generated on 7/26/2025, 12:13:39 AM*\n",
      "findings_count": 1,
      "critical_findings": 0,
      "high_findings": 0,
      "medium_findings": 0,
      "low_findings": 1,
      "audit_status": "completed",
      "created_at": "2025-07-25T22:13:39.260Z",
      "updated_at": "2025-07-25T22:13:39.260Z",
      "processing_time_ms": 9326,
      "error_message": null,
      "audit_engine_version": "1.0.0",
      "static_analysis_tools": "[\"AI Analysis\"]"
    },
    {
      "id": "report_1753482948103_lsjxhop7i",
      "contract_address": "0x22f41abf77905f50df398f21213290597e7414dd",
      "report_json": "{\"findings\":[{\"id\":\"422220de-5758-4186-b2ef-745d0abeff14\",\"category\":\"Analysis Issue\",\"severity\":\"low\",\"title\":\"AI Response Format Issue\",\"description\":\"The AI analysis completed but returned an unexpected format that could not be parsed as structured findings. Response preview: \\\"[   {     \\\"id\\\": \\\"vuln-1\\\",     \\\"category\\\": \\\"Reentrancy\\\",     \\\"severity\\\": \\\"medium\\\",     \\\"swc_id\\\": \\\"SWC-107\\\",     \\\"cwe_id\\\": \\\"CWE-362\\\",     \\\"title\\\": \\\"Potential Reentrancy Vulnerability\\\",     \\\"description\\\": \\\"The `transfer()` and `transferFrom()` functions do not have proper reentrancy protection. An atta...\\\"\",\"recommendation\":\"Review the contract manually, check the AI service configuration, or try the analysis again. The AI may have provided analysis in a non-standard format.\"}],\"categorizedFindings\":{\"security\":[],\"gas_optimization\":[],\"code_quality\":[],\"other\":[{\"id\":\"422220de-5758-4186-b2ef-745d0abeff14\",\"category\":\"Analysis Issue\",\"severity\":\"low\",\"title\":\"AI Response Format Issue\",\"description\":\"The AI analysis completed but returned an unexpected format that could not be parsed as structured findings. Response preview: \\\"[   {     \\\"id\\\": \\\"vuln-1\\\",     \\\"category\\\": \\\"Reentrancy\\\",     \\\"severity\\\": \\\"medium\\\",     \\\"swc_id\\\": \\\"SWC-107\\\",     \\\"cwe_id\\\": \\\"CWE-362\\\",     \\\"title\\\": \\\"Potential Reentrancy Vulnerability\\\",     \\\"description\\\": \\\"The `transfer()` and `transferFrom()` functions do not have proper reentrancy protection. An atta...\\\"\",\"recommendation\":\"Review the contract manually, check the AI service configuration, or try the analysis again. The AI may have provided analysis in a non-standard format.\"}]},\"summary\":{\"total\":1,\"critical\":0,\"high\":0,\"medium\":0,\"low\":1,\"byCategory\":{\"security\":0,\"gas_optimization\":0,\"code_quality\":0,\"other\":1}},\"generatedAt\":\"2025-07-25T22:35:48.001Z\"}",
      "report_markdown": "# Smart Contract Audit Report\n\n## Executive Summary\n\n**Total Findings**: 1\n\n### Severity Distribution\n- **Critical**: 0 🔴\n- **High**: 0 🟠\n- **Medium**: 0 🟡\n- **Low**: 1 🟢\n\n### Category Distribution\n- **Security Issues**: 0 findings\n- **Gas Optimization**: 0 findings\n- **Code Quality**: 0 findings\n- **Other Issues**: 1 findings\n\n---\n\n## 🔍 Other Findings\n\nFound 1 issue in this category.\n\n### 1. AI Response Format Issue 🟢\n\n**Category**: Analysis Issue  \n**Severity**: LOW\n\n**Description**: The AI analysis completed but returned an unexpected format that could not be parsed as structured findings. Response preview: \"[   {     \"id\": \"vuln-1\",     \"category\": \"Reentrancy\",     \"severity\": \"medium\",     \"swc_id\": \"SWC-107\",     \"cwe_id\": \"CWE-362\",     \"title\": \"Potential Reentrancy Vulnerability\",     \"description\": \"The `transfer()` and `transferFrom()` functions do not have proper reentrancy protection. An atta...\"\n\n**💡 Recommendation**: Review the contract manually, check the AI service configuration, or try the analysis again. The AI may have provided analysis in a non-standard format.\n\n---\n\n\n*Report generated on 7/26/2025, 12:35:48 AM*\n",
      "findings_count": 1,
      "critical_findings": 0,
      "high_findings": 0,
      "medium_findings": 0,
      "low_findings": 1,
      "audit_status": "completed",
      "created_at": "2025-07-25T22:35:48.103Z",
      "updated_at": "2025-07-25T22:35:48.103Z",
      "processing_time_ms": 7233,
      "error_message": null,
      "audit_engine_version": "1.0.0",
      "static_analysis_tools": "[\"AI Analysis\"]"
    },
    {
      "id": "report_1753531712390_m4o5isu36",
      "contract_address": "0x700d841e087f4038639b214e849beab622f178c6",
      "report_json": "{\"findings\":[{\"id\":\"39285358-d6f3-4eca-930e-51d60237d49f\",\"category\":\"Analysis Issue\",\"severity\":\"low\",\"title\":\"AI Response Format Issue\",\"description\":\"The AI analysis completed but returned an unexpected format that could not be parsed as structured findings. Response preview: \\\"[   {     \\\"id\\\": \\\"vuln-1\\\",     \\\"category\\\": \\\"Reentrancy\\\",     \\\"severity\\\": \\\"high\\\",     \\\"swc_id\\\": \\\"SWC-107\\\",     \\\"cwe_id\\\": \\\"CWE-362\\\",     \\\"title\\\": \\\"Reentrancy Vulnerability in Swap Function\\\",     \\\"description\\\": \\\"The `swap` function performs external calls to `to` before updating the contract's state, wh...\\\"\",\"recommendation\":\"Review the contract manually, check the AI service configuration, or try the analysis again. The AI may have provided analysis in a non-standard format.\"}],\"categorizedFindings\":{\"security\":[],\"gas_optimization\":[],\"code_quality\":[],\"other\":[{\"id\":\"39285358-d6f3-4eca-930e-51d60237d49f\",\"category\":\"Analysis Issue\",\"severity\":\"low\",\"title\":\"AI Response Format Issue\",\"description\":\"The AI analysis completed but returned an unexpected format that could not be parsed as structured findings. Response preview: \\\"[   {     \\\"id\\\": \\\"vuln-1\\\",     \\\"category\\\": \\\"Reentrancy\\\",     \\\"severity\\\": \\\"high\\\",     \\\"swc_id\\\": \\\"SWC-107\\\",     \\\"cwe_id\\\": \\\"CWE-362\\\",     \\\"title\\\": \\\"Reentrancy Vulnerability in Swap Function\\\",     \\\"description\\\": \\\"The `swap` function performs external calls to `to` before updating the contract's state, wh...\\\"\",\"recommendation\":\"Review the contract manually, check the AI service configuration, or try the analysis again. The AI may have provided analysis in a non-standard format.\"}]},\"summary\":{\"total\":1,\"critical\":0,\"high\":0,\"medium\":0,\"low\":1,\"byCategory\":{\"security\":0,\"gas_optimization\":0,\"code_quality\":0,\"other\":1}},\"generatedAt\":\"2025-07-26T12:08:32.277Z\"}",
      "report_markdown": "# Smart Contract Audit Report\n\n## Executive Summary\n\n**Total Findings**: 1\n\n### Severity Distribution\n- **Critical**: 0 🔴\n- **High**: 0 🟠\n- **Medium**: 0 🟡\n- **Low**: 1 🟢\n\n### Category Distribution\n- **Security Issues**: 0 findings\n- **Gas Optimization**: 0 findings\n- **Code Quality**: 0 findings\n- **Other Issues**: 1 findings\n\n---\n\n## 🔍 Other Findings\n\nFound 1 issue in this category.\n\n### 1. AI Response Format Issue 🟢\n\n**Category**: Analysis Issue  \n**Severity**: LOW\n\n**Description**: The AI analysis completed but returned an unexpected format that could not be parsed as structured findings. Response preview: \"[   {     \"id\": \"vuln-1\",     \"category\": \"Reentrancy\",     \"severity\": \"high\",     \"swc_id\": \"SWC-107\",     \"cwe_id\": \"CWE-362\",     \"title\": \"Reentrancy Vulnerability in Swap Function\",     \"description\": \"The `swap` function performs external calls to `to` before updating the contract's state, wh...\"\n\n**💡 Recommendation**: Review the contract manually, check the AI service configuration, or try the analysis again. The AI may have provided analysis in a non-standard format.\n\n---\n\n\n*Report generated on 7/26/2025, 2:08:32 PM*\n",
      "findings_count": 1,
      "critical_findings": 0,
      "high_findings": 0,
      "medium_findings": 0,
      "low_findings": 1,
      "audit_status": "completed",
      "created_at": "2025-07-26T12:08:32.390Z",
      "updated_at": "2025-07-26T12:08:32.390Z",
      "processing_time_ms": 28330,
      "error_message": null,
      "audit_engine_version": "1.0.0",
      "static_analysis_tools": "[\"AI Analysis\"]"
    },
    {
      "id": "report_1753531986690_ez8xslu53",
      "contract_address": "0x700d841e087f4038639b214e849beab622f178c6",
      "report_json": "{\"findings\":[{\"id\":\"reentrancy-1\",\"category\":\"Reentrancy\",\"severity\":\"high\",\"swc_id\":\"SWC-107\",\"cwe_id\":\"CWE-362\",\"title\":\"Reentrancy Vulnerability in Swap Function\",\"description\":\"The `swap` function performs external calls to `to` before updating the contract's state, which could lead to reentrancy attacks.\",\"lines\":[276,277,278],\"recommendation\":\"Implement the Checks-Effects-Interactions pattern by updating the contract's state before the external call.\"},{\"id\":\"integer-overflow-1\",\"category\":\"Integer Overflow\",\"severity\":\"high\",\"swc_id\":\"SWC-101\",\"cwe_id\":\"CWE-integer-overflow-or-underflow\",\"title\":\"Potential Integer Overflow in Mint Function\",\"description\":\"The `mint` function does not use SafeMath for arithmetic operations, which could lead to integer overflow vulnerabilities.\",\"lines\":[233,234,235,236,237],\"recommendation\":\"Use SafeMath library for all arithmetic operations to prevent integer overflow and underflow issues.\"},{\"id\":\"unchecked-call-1\",\"category\":\"Unchecked Call Return Values\",\"severity\":\"medium\",\"swc_id\":\"SWC-104\",\"cwe_id\":\"CWE-252\",\"title\":\"Unchecked Return Value of External Calls\",\"description\":\"The `_safeTransfer` function does not check the return value of the low-level call, which could lead to unhandled failures.\",\"lines\":[321,322,323,324],\"recommendation\":\"Always check the return value of external calls and handle failures appropriately.\"},{\"id\":\"unprotected-withdrawal-1\",\"category\":\"Unprotected Ether Withdrawal\",\"severity\":\"high\",\"swc_id\":\"SWC-105\",\"cwe_id\":\"CWE-284\",\"title\":\"Unprotected Ether Withdrawal in Burn Function\",\"description\":\"The `burn` function allows anyone to withdraw Ether from the contract without proper access control.\",\"lines\":[352,353,354,355],\"recommendation\":\"Implement access control to restrict the `burn` function to authorized users only.\"},{\"id\":\"tx-origin-1\",\"category\":\"Authorization through tx.origin\",\"severity\":\"medium\",\"swc_id\":\"SWC-115\",\"cwe_id\":\"CWE-477\",\"title\":\"Authorization Based on tx.origin\",\"description\":\"The contract does not use msg.sender for authorization, but instead relies on tx.origin, which is vulnerable to phishing attacks.\",\"lines\":[],\"recommendation\":\"Use msg.sender for all authorization checks instead of tx.origin.\"},{\"id\":\"inefficient-loop-1\",\"category\":\"Inefficient Loops and Storage Access\",\"severity\":\"medium\",\"cwe_id\":\"CWE-400\",\"title\":\"Inefficient Loop in Skim Function\",\"description\":\"The `skim` function has an unbounded loop that iterates over the entire token balance, which can lead to high gas consumption.\",\"lines\":[375,376,377,378],\"recommendation\":\"Consider using a more efficient data structure or limiting the loop size to reduce gas costs.\"},{\"id\":\"redundant-computation-1\",\"category\":\"Redundant Computations\",\"severity\":\"low\",\"title\":\"Redundant Keccak256 Computation\",\"description\":\"The contract computes the DOMAIN_SEPARATOR in the constructor, which is a constant value and could be precomputed.\",\"lines\":[79,80,81,82,83],\"recommendation\":\"Precompute the DOMAIN_SEPARATOR value and store it as a constant to save gas.\"},{\"id\":\"suboptimal-data-1\",\"category\":\"Suboptimal Data Structures\",\"severity\":\"medium\",\"title\":\"Inefficient Use of Mapping\",\"description\":\"The contract uses a mapping to store the nonces, which can be inefficient for large numbers of users. Consider using an array or a more efficient data structure.\",\"lines\":[92],\"recommendation\":\"Evaluate alternative data structures to store the nonces, such as an array or a more efficient mapping implementation.\"},{\"id\":\"missing-view-1\",\"category\":\"Missing View/Pure Function Modifiers\",\"severity\":\"low\",\"title\":\"Missing View Modifier\",\"description\":\"The `getReserves` function does not have the view modifier, even though it does not modify the contract's state.\",\"lines\":[193,194,195],\"recommendation\":\"Add the view modifier to the `getReserves` function to indicate that it does not modify the contract's state.\"},{\"id\":\"unused-variable-1\",\"category\":\"Unused Variables and Functions\",\"severity\":\"low\",\"title\":\"Unused Variable\",\"description\":\"The `MINIMUM_LIQUIDITY` constant is defined but not used in the contract.\",\"lines\":[185],\"recommendation\":\"Remove the unused `MINIMUM_LIQUIDITY` constant to reduce contract size and deployment costs.\"},{\"id\":\"missing-error-1\",\"category\":\"Missing Error Messages\",\"severity\":\"low\",\"title\":\"Missing Error Message\",\"description\":\"The `require` statement in the `_update` function does not provide a custom error message.\",\"lines\":[218,219],\"recommendation\":\"Add a descriptive error message to the `require` statement to improve the contract's error handling.\"},{\"id\":\"inconsistent-naming-1\",\"category\":\"Inconsistent Naming Conventions\",\"severity\":\"low\",\"title\":\"Inconsistent Function Naming\",\"description\":\"The `_safeTransfer` function name does not follow the Solidity naming conventions.\",\"lines\":[321,322,323,324],\"recommendation\":\"Rename the `_safeTransfer` function to follow the Solidity naming conventions, such as `safeTransfer`.\"},{\"id\":\"lack-of-documentation-1\",\"category\":\"Lack of Documentation\",\"severity\":\"low\",\"title\":\"Missing Function Documentation\",\"description\":\"The contract lacks NatSpec comments for several functions, including `_update`, `_mintFee`, and `_safeTransfer`.\",\"lines\":[210,239,321],\"recommendation\":\"Add NatSpec comments to document the purpose, parameters, and return values of the undocumented functions.\"}],\"categorizedFindings\":{\"security\":[{\"id\":\"reentrancy-1\",\"category\":\"Reentrancy\",\"severity\":\"high\",\"swc_id\":\"SWC-107\",\"cwe_id\":\"CWE-362\",\"title\":\"Reentrancy Vulnerability in Swap Function\",\"description\":\"The `swap` function performs external calls to `to` before updating the contract's state, which could lead to reentrancy attacks.\",\"lines\":[276,277,278],\"recommendation\":\"Implement the Checks-Effects-Interactions pattern by updating the contract's state before the external call.\"},{\"id\":\"integer-overflow-1\",\"category\":\"Integer Overflow\",\"severity\":\"high\",\"swc_id\":\"SWC-101\",\"cwe_id\":\"CWE-integer-overflow-or-underflow\",\"title\":\"Potential Integer Overflow in Mint Function\",\"description\":\"The `mint` function does not use SafeMath for arithmetic operations, which could lead to integer overflow vulnerabilities.\",\"lines\":[233,234,235,236,237],\"recommendation\":\"Use SafeMath library for all arithmetic operations to prevent integer overflow and underflow issues.\"},{\"id\":\"unchecked-call-1\",\"category\":\"Unchecked Call Return Values\",\"severity\":\"medium\",\"swc_id\":\"SWC-104\",\"cwe_id\":\"CWE-252\",\"title\":\"Unchecked Return Value of External Calls\",\"description\":\"The `_safeTransfer` function does not check the return value of the low-level call, which could lead to unhandled failures.\",\"lines\":[321,322,323,324],\"recommendation\":\"Always check the return value of external calls and handle failures appropriately.\"},{\"id\":\"unprotected-withdrawal-1\",\"category\":\"Unprotected Ether Withdrawal\",\"severity\":\"high\",\"swc_id\":\"SWC-105\",\"cwe_id\":\"CWE-284\",\"title\":\"Unprotected Ether Withdrawal in Burn Function\",\"description\":\"The `burn` function allows anyone to withdraw Ether from the contract without proper access control.\",\"lines\":[352,353,354,355],\"recommendation\":\"Implement access control to restrict the `burn` function to authorized users only.\"},{\"id\":\"tx-origin-1\",\"category\":\"Authorization through tx.origin\",\"severity\":\"medium\",\"swc_id\":\"SWC-115\",\"cwe_id\":\"CWE-477\",\"title\":\"Authorization Based on tx.origin\",\"description\":\"The contract does not use msg.sender for authorization, but instead relies on tx.origin, which is vulnerable to phishing attacks.\",\"lines\":[],\"recommendation\":\"Use msg.sender for all authorization checks instead of tx.origin.\"}],\"gas_optimization\":[{\"id\":\"inefficient-loop-1\",\"category\":\"Inefficient Loops and Storage Access\",\"severity\":\"medium\",\"cwe_id\":\"CWE-400\",\"title\":\"Inefficient Loop in Skim Function\",\"description\":\"The `skim` function has an unbounded loop that iterates over the entire token balance, which can lead to high gas consumption.\",\"lines\":[375,376,377,378],\"recommendation\":\"Consider using a more efficient data structure or limiting the loop size to reduce gas costs.\"},{\"id\":\"redundant-computation-1\",\"category\":\"Redundant Computations\",\"severity\":\"low\",\"title\":\"Redundant Keccak256 Computation\",\"description\":\"The contract computes the DOMAIN_SEPARATOR in the constructor, which is a constant value and could be precomputed.\",\"lines\":[79,80,81,82,83],\"recommendation\":\"Precompute the DOMAIN_SEPARATOR value and store it as a constant to save gas.\"},{\"id\":\"suboptimal-data-1\",\"category\":\"Suboptimal Data Structures\",\"severity\":\"medium\",\"title\":\"Inefficient Use of Mapping\",\"description\":\"The contract uses a mapping to store the nonces, which can be inefficient for large numbers of users. Consider using an array or a more efficient data structure.\",\"lines\":[92],\"recommendation\":\"Evaluate alternative data structures to store the nonces, such as an array or a more efficient mapping implementation.\"},{\"id\":\"missing-view-1\",\"category\":\"Missing View/Pure Function Modifiers\",\"severity\":\"low\",\"title\":\"Missing View Modifier\",\"description\":\"The `getReserves` function does not have the view modifier, even though it does not modify the contract's state.\",\"lines\":[193,194,195],\"recommendation\":\"Add the view modifier to the `getReserves` function to indicate that it does not modify the contract's state.\"}],\"code_quality\":[{\"id\":\"unused-variable-1\",\"category\":\"Unused Variables and Functions\",\"severity\":\"low\",\"title\":\"Unused Variable\",\"description\":\"The `MINIMUM_LIQUIDITY` constant is defined but not used in the contract.\",\"lines\":[185],\"recommendation\":\"Remove the unused `MINIMUM_LIQUIDITY` constant to reduce contract size and deployment costs.\"},{\"id\":\"missing-error-1\",\"category\":\"Missing Error Messages\",\"severity\":\"low\",\"title\":\"Missing Error Message\",\"description\":\"The `require` statement in the `_update` function does not provide a custom error message.\",\"lines\":[218,219],\"recommendation\":\"Add a descriptive error message to the `require` statement to improve the contract's error handling.\"},{\"id\":\"inconsistent-naming-1\",\"category\":\"Inconsistent Naming Conventions\",\"severity\":\"low\",\"title\":\"Inconsistent Function Naming\",\"description\":\"The `_safeTransfer` function name does not follow the Solidity naming conventions.\",\"lines\":[321,322,323,324],\"recommendation\":\"Rename the `_safeTransfer` function to follow the Solidity naming conventions, such as `safeTransfer`.\"},{\"id\":\"lack-of-documentation-1\",\"category\":\"Lack of Documentation\",\"severity\":\"low\",\"title\":\"Missing Function Documentation\",\"description\":\"The contract lacks NatSpec comments for several functions, including `_update`, `_mintFee`, and `_safeTransfer`.\",\"lines\":[210,239,321],\"recommendation\":\"Add NatSpec comments to document the purpose, parameters, and return values of the undocumented functions.\"}],\"other\":[]},\"summary\":{\"total\":13,\"critical\":0,\"high\":3,\"medium\":4,\"low\":6,\"byCategory\":{\"security\":5,\"gas_optimization\":4,\"code_quality\":4,\"other\":0}},\"generatedAt\":\"2025-07-26T12:13:06.671Z\"}",
      "report_markdown": "# Smart Contract Audit Report\n\n## Executive Summary\n\n**Total Findings**: 13\n\n### Severity Distribution\n- **Critical**: 0 🔴\n- **High**: 3 🟠\n- **Medium**: 4 🟡\n- **Low**: 6 🟢\n\n### Category Distribution\n- **Security Issues**: 5 findings\n- **Gas Optimization**: 4 findings\n- **Code Quality**: 4 findings\n- **Other Issues**: 0 findings\n\n---\n\n## 🔒 Security Issues\n\nFound 5 issues in this category.\n\n### 1. Reentrancy Vulnerability in Swap Function 🟠\n\n**Category**: Reentrancy  \n**Severity**: HIGH\n\n**Description**: The `swap` function performs external calls to `to` before updating the contract's state, which could lead to reentrancy attacks.\n\n**Standards**: SWC-107, CWE-362\n\n**Affected Lines**: 276, 277, 278\n\n**💡 Recommendation**: Implement the Checks-Effects-Interactions pattern by updating the contract's state before the external call.\n\n---\n\n### 2. Potential Integer Overflow in Mint Function 🟠\n\n**Category**: Integer Overflow  \n**Severity**: HIGH\n\n**Description**: The `mint` function does not use SafeMath for arithmetic operations, which could lead to integer overflow vulnerabilities.\n\n**Standards**: SWC-101, CWE-integer-overflow-or-underflow\n\n**Affected Lines**: 233, 234, 235, 236, 237\n\n**💡 Recommendation**: Use SafeMath library for all arithmetic operations to prevent integer overflow and underflow issues.\n\n---\n\n### 3. Unchecked Return Value of External Calls 🟡\n\n**Category**: Unchecked Call Return Values  \n**Severity**: MEDIUM\n\n**Description**: The `_safeTransfer` function does not check the return value of the low-level call, which could lead to unhandled failures.\n\n**Standards**: SWC-104, CWE-252\n\n**Affected Lines**: 321, 322, 323, 324\n\n**💡 Recommendation**: Always check the return value of external calls and handle failures appropriately.\n\n---\n\n### 4. Unprotected Ether Withdrawal in Burn Function 🟠\n\n**Category**: Unprotected Ether Withdrawal  \n**Severity**: HIGH\n\n**Description**: The `burn` function allows anyone to withdraw Ether from the contract without proper access control.\n\n**Standards**: SWC-105, CWE-284\n\n**Affected Lines**: 352, 353, 354, 355\n\n**💡 Recommendation**: Implement access control to restrict the `burn` function to authorized users only.\n\n---\n\n### 5. Authorization Based on tx.origin 🟡\n\n**Category**: Authorization through tx.origin  \n**Severity**: MEDIUM\n\n**Description**: The contract does not use msg.sender for authorization, but instead relies on tx.origin, which is vulnerable to phishing attacks.\n\n**Standards**: SWC-115, CWE-477\n\n**💡 Recommendation**: Use msg.sender for all authorization checks instead of tx.origin.\n\n---\n\n## ⛽ Gas Optimization Opportunities\n\nFound 4 issues in this category.\n\n### 1. Inefficient Loop in Skim Function 🟡\n\n**Category**: Inefficient Loops and Storage Access  \n**Severity**: MEDIUM\n\n**Description**: The `skim` function has an unbounded loop that iterates over the entire token balance, which can lead to high gas consumption.\n\n**Standards**: CWE-400\n\n**Affected Lines**: 375, 376, 377, 378\n\n**💡 Recommendation**: Consider using a more efficient data structure or limiting the loop size to reduce gas costs.\n\n---\n\n### 2. Redundant Keccak256 Computation 🟢\n\n**Category**: Redundant Computations  \n**Severity**: LOW\n\n**Description**: The contract computes the DOMAIN_SEPARATOR in the constructor, which is a constant value and could be precomputed.\n\n**Affected Lines**: 79, 80, 81, 82, 83\n\n**💡 Recommendation**: Precompute the DOMAIN_SEPARATOR value and store it as a constant to save gas.\n\n---\n\n### 3. Inefficient Use of Mapping 🟡\n\n**Category**: Suboptimal Data Structures  \n**Severity**: MEDIUM\n\n**Description**: The contract uses a mapping to store the nonces, which can be inefficient for large numbers of users. Consider using an array or a more efficient data structure.\n\n**Affected Lines**: 92\n\n**💡 Recommendation**: Evaluate alternative data structures to store the nonces, such as an array or a more efficient mapping implementation.\n\n---\n\n### 4. Missing View Modifier 🟢\n\n**Category**: Missing View/Pure Function Modifiers  \n**Severity**: LOW\n\n**Description**: The `getReserves` function does not have the view modifier, even though it does not modify the contract's state.\n\n**Affected Lines**: 193, 194, 195\n\n**💡 Recommendation**: Add the view modifier to the `getReserves` function to indicate that it does not modify the contract's state.\n\n---\n\n## 📝 Code Quality Improvements\n\nFound 4 issues in this category.\n\n### 1. Unused Variable 🟢\n\n**Category**: Unused Variables and Functions  \n**Severity**: LOW\n\n**Description**: The `MINIMUM_LIQUIDITY` constant is defined but not used in the contract.\n\n**Affected Lines**: 185\n\n**💡 Recommendation**: Remove the unused `MINIMUM_LIQUIDITY` constant to reduce contract size and deployment costs.\n\n---\n\n### 2. Missing Error Message 🟢\n\n**Category**: Missing Error Messages  \n**Severity**: LOW\n\n**Description**: The `require` statement in the `_update` function does not provide a custom error message.\n\n**Affected Lines**: 218, 219\n\n**💡 Recommendation**: Add a descriptive error message to the `require` statement to improve the contract's error handling.\n\n---\n\n### 3. Inconsistent Function Naming 🟢\n\n**Category**: Inconsistent Naming Conventions  \n**Severity**: LOW\n\n**Description**: The `_safeTransfer` function name does not follow the Solidity naming conventions.\n\n**Affected Lines**: 321, 322, 323, 324\n\n**💡 Recommendation**: Rename the `_safeTransfer` function to follow the Solidity naming conventions, such as `safeTransfer`.\n\n---\n\n### 4. Missing Function Documentation 🟢\n\n**Category**: Lack of Documentation  \n**Severity**: LOW\n\n**Description**: The contract lacks NatSpec comments for several functions, including `_update`, `_mintFee`, and `_safeTransfer`.\n\n**Affected Lines**: 210, 239, 321\n\n**💡 Recommendation**: Add NatSpec comments to document the purpose, parameters, and return values of the undocumented functions.\n\n---\n\n\n*Report generated on 7/26/2025, 2:13:06 PM*\n",
      "findings_count": 13,
      "critical_findings": 0,
      "high_findings": 3,
      "medium_findings": 4,
      "low_findings": 6,
      "audit_status": "completed",
      "created_at": "2025-07-26T12:13:06.690Z",
      "updated_at": "2025-07-26T12:13:06.690Z",
      "processing_time_ms": 13458,
      "error_message": null,
      "audit_engine_version": "1.0.0",
      "static_analysis_tools": "[\"AI Analysis\"]"
    },
    {
      "id": "report_1753535243534_7m60sldd7",
      "contract_address": "0x700d841e087f4038639b214e849beab622f178c6",
      "report_json": "{\"findings\":[{\"id\":\"vuln-1\",\"category\":\"Reentrancy\",\"severity\":\"high\",\"swc_id\":\"SWC-107\",\"cwe_id\":\"CWE-362\",\"title\":\"Reentrancy Vulnerability in Burn Function\",\"description\":\"The burn function performs state updates after external calls, which can lead to reentrancy attacks.\",\"lines\":[171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194],\"codeSnippet\":\"function burn(address to)\\n external\\n lock\\n returns (uint256 amount0, uint256 amount1)\\n {\\n (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\\n address _token0 = token0; // gas savings\\n address _token1 = token1; // gas savings\\n uint256 balance0 = IERC20(_token0).balanceOf(address(this));\\n uint256 balance1 = IERC20(_token1).balanceOf(address(this));\\n uint256 liquidity = balanceOf[address(this)];\\n\\n bool feeOn = _mintFee(_reserve0, _reserve1);\\n uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\\n amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution\\n amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution\\n require(\\n amount0 > 0 && amount1 > 0,\\n \\\"Swappi: INSUFFICIENT_LIQUIDITY_BURNED\\\"\\n );\\n _burn(address(this), liquidity);\\n _safeTransfer(_token0, to, amount0);\\n _safeTransfer(_token1, to, amount1);\\n balance0 = IERC20(_token0).balanceOf(address(this));\\n balance1 = IERC20(_token1).balanceOf(address(this));\\n\\n _update(balance0, balance1, _reserve0, _reserve1);\\n if (feeOn) kLast = uint256(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\\n emit Burn(msg.sender, amount0, amount1, to);\\n }\",\"location\":\"burn function in SwappiPair contract\",\"recommendation\":\"Implement the Checks-Effects-Interactions pattern by performing all state updates before the external calls. Additionally, consider using a reentrancy guard modifier to protect critical functions.\",\"accuracy\":0.9000000000000001},{\"id\":\"vuln-2\",\"category\":\"Integer Overflow/Underflow\",\"severity\":\"high\",\"swc_id\":\"SWC-101\",\"cwe_id\":\"CWE-682\",\"title\":\"Potential Integer Overflow in Mint Function\",\"description\":\"The mint function performs arithmetic operations without proper overflow/underflow checks, which could lead to integer overflow vulnerabilities.\",\"lines\":[141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168],\"codeSnippet\":\"function mint(address to) external lock returns (uint256 liquidity) {\\n (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\\n uint256 balance0 = IERC20(token0).balanceOf(address(this));\\n uint256 balance1 = IERC20(token1).balanceOf(address(this));\\n uint256 amount0 = balance0.sub(_reserve0);\\n uint256 amount1 = balance1.sub(_reserve1);\\n\\n bool feeOn = _mintFee(_reserve0, _reserve1);\\n uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\\n if (_totalSupply == 0) {\\n liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\\n _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\\n } else {\\n liquidity = Math.min(\\n amount0.mul(_totalSupply) / _reserve0,\\n amount1.mul(_totalSupply) / _reserve1\\n );\\n }\\n require(liquidity > 0, \\\"Swappi: INSUFFICIENT_LIQUIDITY_MINTED\\\");\\n _mint(to, liquidity);\\n\\n _update(balance0, balance1, _reserve0, _reserve1);\\n if (feeOn) kLast = uint256(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\\n emit Mint(msg.sender, amount0, amount1);\\n }\",\"location\":\"mint function in SwappiPair contract\",\"recommendation\":\"Implement SafeMath or equivalent overflow/underflow protection for all arithmetic operations. Additionally, consider adding explicit checks for overflow/underflow conditions.\",\"accuracy\":1},{\"id\":\"vuln-3\",\"category\":\"Unchecked Call Return Values\",\"severity\":\"medium\",\"swc_id\":\"SWC-104\",\"cwe_id\":\"CWE-252\",\"title\":\"Unchecked Return Value in _safeTransfer Function\",\"description\":\"The _safeTransfer function does not properly check the return value of the low-level token transfer call, which could lead to undetected failures.\",\"lines\":[366,367,368,369,370,371,372,373,374,375,376,377],\"codeSnippet\":\"function _safeTransfer(\\n address token,\\n address to,\\n uint256 value\\n ) private {\\n (bool success, bytes memory data) =\\n token.call(abi.encodeWithSelector(SELECTOR, to, value));\\n require(\\n success && (data.length == 0 || abi.decode(data, (bool))),\\n \\\"Swappi: TRANSFER_FAILED\\\"\\n );\\n }\",\"location\":\"_safeTransfer function in SwappiPair contract\",\"recommendation\":\"Implement proper error handling for the token transfer call. Consider using the OpenZeppelin's SafeERC20 library or equivalent to handle ERC20 token transfers safely.\",\"accuracy\":0.2},{\"id\":\"vuln-4\",\"category\":\"Unprotected Ether Withdrawal\",\"severity\":\"high\",\"swc_id\":\"SWC-105\",\"cwe_id\":\"CWE-284\",\"title\":\"Unprotected Ether Withdrawal in Skim Function\",\"description\":\"The skim function allows anyone to withdraw the contract's excess token balances, which could lead to unauthorized fund withdrawals.\",\"lines\":[585,586,587,588,589,590,591,592,593,594,595,596,597,598],\"codeSnippet\":\"function skim(address to) external lock {\\n address _token0 = token0; // gas savings\\n address _token1 = token1; // gas savings\\n _safeTransfer(\\n _token0,\\n to,\\n IERC20(_token0).balanceOf(address(this)).sub(reserve0)\\n );\\n _safeTransfer(\\n _token1,\\n to,\\n IERC20(_token1).balanceOf(address(this)).sub(reserve1)\\n );\\n }\",\"location\":\"skim function in SwappiPair contract\",\"recommendation\":\"Implement access control to restrict the skim function to authorized entities only, such as the contract owner or a designated operator.\",\"accuracy\":0.4},{\"id\":\"vuln-5\",\"category\":\"Authorization through tx.origin\",\"severity\":\"medium\",\"swc_id\":\"SWC-115\",\"cwe_id\":\"CWE-477\",\"title\":\"Authorization Based on tx.origin\",\"description\":\"The contract does not use msg.sender for authorization, but instead relies on tx.origin, which can lead to vulnerabilities if the contract is called through a proxy or another contract.\",\"lines\":[],\"codeSnippet\":\"The contract does not contain any instances of using tx.origin for authorization.\",\"location\":\"N/A\",\"recommendation\":\"Use msg.sender instead of tx.origin for all authorization checks to ensure secure access control.\",\"accuracy\":0}],\"categorizedFindings\":{\"security\":[{\"id\":\"vuln-1\",\"category\":\"Reentrancy\",\"severity\":\"high\",\"swc_id\":\"SWC-107\",\"cwe_id\":\"CWE-362\",\"title\":\"Reentrancy Vulnerability in Burn Function\",\"description\":\"The burn function performs state updates after external calls, which can lead to reentrancy attacks.\",\"lines\":[171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194],\"codeSnippet\":\"function burn(address to)\\n external\\n lock\\n returns (uint256 amount0, uint256 amount1)\\n {\\n (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\\n address _token0 = token0; // gas savings\\n address _token1 = token1; // gas savings\\n uint256 balance0 = IERC20(_token0).balanceOf(address(this));\\n uint256 balance1 = IERC20(_token1).balanceOf(address(this));\\n uint256 liquidity = balanceOf[address(this)];\\n\\n bool feeOn = _mintFee(_reserve0, _reserve1);\\n uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\\n amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution\\n amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution\\n require(\\n amount0 > 0 && amount1 > 0,\\n \\\"Swappi: INSUFFICIENT_LIQUIDITY_BURNED\\\"\\n );\\n _burn(address(this), liquidity);\\n _safeTransfer(_token0, to, amount0);\\n _safeTransfer(_token1, to, amount1);\\n balance0 = IERC20(_token0).balanceOf(address(this));\\n balance1 = IERC20(_token1).balanceOf(address(this));\\n\\n _update(balance0, balance1, _reserve0, _reserve1);\\n if (feeOn) kLast = uint256(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\\n emit Burn(msg.sender, amount0, amount1, to);\\n }\",\"location\":\"burn function in SwappiPair contract\",\"recommendation\":\"Implement the Checks-Effects-Interactions pattern by performing all state updates before the external calls. Additionally, consider using a reentrancy guard modifier to protect critical functions.\",\"accuracy\":0.9000000000000001},{\"id\":\"vuln-2\",\"category\":\"Integer Overflow/Underflow\",\"severity\":\"high\",\"swc_id\":\"SWC-101\",\"cwe_id\":\"CWE-682\",\"title\":\"Potential Integer Overflow in Mint Function\",\"description\":\"The mint function performs arithmetic operations without proper overflow/underflow checks, which could lead to integer overflow vulnerabilities.\",\"lines\":[141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168],\"codeSnippet\":\"function mint(address to) external lock returns (uint256 liquidity) {\\n (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\\n uint256 balance0 = IERC20(token0).balanceOf(address(this));\\n uint256 balance1 = IERC20(token1).balanceOf(address(this));\\n uint256 amount0 = balance0.sub(_reserve0);\\n uint256 amount1 = balance1.sub(_reserve1);\\n\\n bool feeOn = _mintFee(_reserve0, _reserve1);\\n uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\\n if (_totalSupply == 0) {\\n liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\\n _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\\n } else {\\n liquidity = Math.min(\\n amount0.mul(_totalSupply) / _reserve0,\\n amount1.mul(_totalSupply) / _reserve1\\n );\\n }\\n require(liquidity > 0, \\\"Swappi: INSUFFICIENT_LIQUIDITY_MINTED\\\");\\n _mint(to, liquidity);\\n\\n _update(balance0, balance1, _reserve0, _reserve1);\\n if (feeOn) kLast = uint256(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\\n emit Mint(msg.sender, amount0, amount1);\\n }\",\"location\":\"mint function in SwappiPair contract\",\"recommendation\":\"Implement SafeMath or equivalent overflow/underflow protection for all arithmetic operations. Additionally, consider adding explicit checks for overflow/underflow conditions.\",\"accuracy\":1},{\"id\":\"vuln-3\",\"category\":\"Unchecked Call Return Values\",\"severity\":\"medium\",\"swc_id\":\"SWC-104\",\"cwe_id\":\"CWE-252\",\"title\":\"Unchecked Return Value in _safeTransfer Function\",\"description\":\"The _safeTransfer function does not properly check the return value of the low-level token transfer call, which could lead to undetected failures.\",\"lines\":[366,367,368,369,370,371,372,373,374,375,376,377],\"codeSnippet\":\"function _safeTransfer(\\n address token,\\n address to,\\n uint256 value\\n ) private {\\n (bool success, bytes memory data) =\\n token.call(abi.encodeWithSelector(SELECTOR, to, value));\\n require(\\n success && (data.length == 0 || abi.decode(data, (bool))),\\n \\\"Swappi: TRANSFER_FAILED\\\"\\n );\\n }\",\"location\":\"_safeTransfer function in SwappiPair contract\",\"recommendation\":\"Implement proper error handling for the token transfer call. Consider using the OpenZeppelin's SafeERC20 library or equivalent to handle ERC20 token transfers safely.\",\"accuracy\":0.2},{\"id\":\"vuln-4\",\"category\":\"Unprotected Ether Withdrawal\",\"severity\":\"high\",\"swc_id\":\"SWC-105\",\"cwe_id\":\"CWE-284\",\"title\":\"Unprotected Ether Withdrawal in Skim Function\",\"description\":\"The skim function allows anyone to withdraw the contract's excess token balances, which could lead to unauthorized fund withdrawals.\",\"lines\":[585,586,587,588,589,590,591,592,593,594,595,596,597,598],\"codeSnippet\":\"function skim(address to) external lock {\\n address _token0 = token0; // gas savings\\n address _token1 = token1; // gas savings\\n _safeTransfer(\\n _token0,\\n to,\\n IERC20(_token0).balanceOf(address(this)).sub(reserve0)\\n );\\n _safeTransfer(\\n _token1,\\n to,\\n IERC20(_token1).balanceOf(address(this)).sub(reserve1)\\n );\\n }\",\"location\":\"skim function in SwappiPair contract\",\"recommendation\":\"Implement access control to restrict the skim function to authorized entities only, such as the contract owner or a designated operator.\",\"accuracy\":0.4},{\"id\":\"vuln-5\",\"category\":\"Authorization through tx.origin\",\"severity\":\"medium\",\"swc_id\":\"SWC-115\",\"cwe_id\":\"CWE-477\",\"title\":\"Authorization Based on tx.origin\",\"description\":\"The contract does not use msg.sender for authorization, but instead relies on tx.origin, which can lead to vulnerabilities if the contract is called through a proxy or another contract.\",\"lines\":[],\"codeSnippet\":\"The contract does not contain any instances of using tx.origin for authorization.\",\"location\":\"N/A\",\"recommendation\":\"Use msg.sender instead of tx.origin for all authorization checks to ensure secure access control.\",\"accuracy\":0}],\"gas_optimization\":[],\"code_quality\":[],\"other\":[]},\"summary\":{\"total\":5,\"critical\":0,\"high\":3,\"medium\":2,\"low\":0,\"byCategory\":{\"security\":5,\"gas_optimization\":0,\"code_quality\":0,\"other\":0}},\"generatedAt\":\"2025-07-26T13:07:23.471Z\"}",
      "report_markdown": "# Smart Contract Audit Report\n\n## Executive Summary\n\n**Total Findings**: 5\n\n### Severity Distribution\n- **Critical**: 0 🔴\n- **High**: 3 🟠\n- **Medium**: 2 🟡\n- **Low**: 0 🟢\n\n### Category Distribution\n- **Security Issues**: 5 findings\n- **Gas Optimization**: 0 findings\n- **Code Quality**: 0 findings\n- **Other Issues**: 0 findings\n\n---\n\n## 🔒 Security Issues\n\nFound 5 issues in this category.\n\n### 1. Reentrancy Vulnerability in Burn Function 🟠\n\n**Category**: Reentrancy  \n**Severity**: HIGH\n\n**Description**: The burn function performs state updates after external calls, which can lead to reentrancy attacks.\n\n**Standards**: SWC-107, CWE-362\n\n**Location**: burn function in SwappiPair contract\n\n**Affected Lines**: 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194\n\n**💡 Recommendation**: Implement the Checks-Effects-Interactions pattern by performing all state updates before the external calls. Additionally, consider using a reentrancy guard modifier to protect critical functions.\n\n---\n\n### 2. Potential Integer Overflow in Mint Function 🟠\n\n**Category**: Integer Overflow/Underflow  \n**Severity**: HIGH\n\n**Description**: The mint function performs arithmetic operations without proper overflow/underflow checks, which could lead to integer overflow vulnerabilities.\n\n**Standards**: SWC-101, CWE-682\n\n**Location**: mint function in SwappiPair contract\n\n**Affected Lines**: 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168\n\n**💡 Recommendation**: Implement SafeMath or equivalent overflow/underflow protection for all arithmetic operations. Additionally, consider adding explicit checks for overflow/underflow conditions.\n\n---\n\n### 3. Unchecked Return Value in _safeTransfer Function 🟡\n\n**Category**: Unchecked Call Return Values  \n**Severity**: MEDIUM\n\n**Description**: The _safeTransfer function does not properly check the return value of the low-level token transfer call, which could lead to undetected failures.\n\n**Standards**: SWC-104, CWE-252\n\n**Location**: _safeTransfer function in SwappiPair contract\n\n**Affected Lines**: 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377\n\n**💡 Recommendation**: Implement proper error handling for the token transfer call. Consider using the OpenZeppelin's SafeERC20 library or equivalent to handle ERC20 token transfers safely.\n\n---\n\n### 4. Unprotected Ether Withdrawal in Skim Function 🟠\n\n**Category**: Unprotected Ether Withdrawal  \n**Severity**: HIGH\n\n**Description**: The skim function allows anyone to withdraw the contract's excess token balances, which could lead to unauthorized fund withdrawals.\n\n**Standards**: SWC-105, CWE-284\n\n**Location**: skim function in SwappiPair contract\n\n**Affected Lines**: 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598\n\n**💡 Recommendation**: Implement access control to restrict the skim function to authorized entities only, such as the contract owner or a designated operator.\n\n---\n\n### 5. Authorization Based on tx.origin 🟡\n\n**Category**: Authorization through tx.origin  \n**Severity**: MEDIUM\n\n**Description**: The contract does not use msg.sender for authorization, but instead relies on tx.origin, which can lead to vulnerabilities if the contract is called through a proxy or another contract.\n\n**Standards**: SWC-115, CWE-477\n\n**Location**: N/A\n\n**💡 Recommendation**: Use msg.sender instead of tx.origin for all authorization checks to ensure secure access control.\n\n---\n\n\n*Report generated on 7/26/2025, 3:07:23 PM*\n",
      "findings_count": 5,
      "critical_findings": 0,
      "high_findings": 3,
      "medium_findings": 2,
      "low_findings": 0,
      "audit_status": "completed",
      "created_at": "2025-07-26T13:07:23.534Z",
      "updated_at": "2025-07-26T13:07:23.534Z",
      "processing_time_ms": 17237,
      "error_message": null,
      "audit_engine_version": "1.0.0",
      "static_analysis_tools": "[\"AI Analysis\"]"
    },
    {
      "id": "report_1753545692491_ty6alkbuj",
      "contract_address": "0x700d841e087f4038639b214e849beab622f178c6",
      "report_json": "{\"findings\":[{\"id\":\"b66083a9-023a-4723-8d70-552725d6036b\",\"category\":\"Analysis Issue\",\"severity\":\"low\",\"title\":\"AI Response Format Issue\",\"description\":\"The AI analysis completed but returned an unexpected format that could not be parsed as structured findings. Response preview: \\\"[   {     \\\"id\\\": \\\"vuln-1\\\",     \\\"category\\\": \\\"Reentrancy\\\",     \\\"severity\\\": \\\"high\\\",     \\\"swc_id\\\": \\\"SWC-107\\\",     \\\"cwe_id\\\": \\\"CWE-362\\\",     \\\"title\\\": \\\"Reentrancy Vulnerability in Burn Function\\\",     \\\"description\\\": \\\"The burn function performs state updates after external calls, which can lead to reentrancy...\\\"\",\"recommendation\":\"Review the contract manually, check the AI service configuration, or try the analysis again. The AI may have provided analysis in a non-standard format.\",\"accuracy\":0}],\"categorizedFindings\":{\"security\":[],\"gas_optimization\":[],\"code_quality\":[],\"other\":[{\"id\":\"b66083a9-023a-4723-8d70-552725d6036b\",\"category\":\"Analysis Issue\",\"severity\":\"low\",\"title\":\"AI Response Format Issue\",\"description\":\"The AI analysis completed but returned an unexpected format that could not be parsed as structured findings. Response preview: \\\"[   {     \\\"id\\\": \\\"vuln-1\\\",     \\\"category\\\": \\\"Reentrancy\\\",     \\\"severity\\\": \\\"high\\\",     \\\"swc_id\\\": \\\"SWC-107\\\",     \\\"cwe_id\\\": \\\"CWE-362\\\",     \\\"title\\\": \\\"Reentrancy Vulnerability in Burn Function\\\",     \\\"description\\\": \\\"The burn function performs state updates after external calls, which can lead to reentrancy...\\\"\",\"recommendation\":\"Review the contract manually, check the AI service configuration, or try the analysis again. The AI may have provided analysis in a non-standard format.\",\"accuracy\":0}]},\"summary\":{\"total\":1,\"critical\":0,\"high\":0,\"medium\":0,\"low\":1,\"byCategory\":{\"security\":0,\"gas_optimization\":0,\"code_quality\":0,\"other\":1}},\"generatedAt\":\"2025-07-26T16:01:32.396Z\"}",
      "report_markdown": "# Smart Contract Audit Report\n\n## Executive Summary\n\n**Total Findings**: 1\n\n### Severity Distribution\n- **Critical**: 0 🔴\n- **High**: 0 🟠\n- **Medium**: 0 🟡\n- **Low**: 1 🟢\n\n### Category Distribution\n- **Security Issues**: 0 findings\n- **Gas Optimization**: 0 findings\n- **Code Quality**: 0 findings\n- **Other Issues**: 1 findings\n\n---\n\n## 🔍 Other Findings\n\nFound 1 issue in this category.\n\n### 1. AI Response Format Issue 🟢\n\n**Category**: Analysis Issue  \n**Severity**: LOW\n\n**Description**: The AI analysis completed but returned an unexpected format that could not be parsed as structured findings. Response preview: \"[   {     \"id\": \"vuln-1\",     \"category\": \"Reentrancy\",     \"severity\": \"high\",     \"swc_id\": \"SWC-107\",     \"cwe_id\": \"CWE-362\",     \"title\": \"Reentrancy Vulnerability in Burn Function\",     \"description\": \"The burn function performs state updates after external calls, which can lead to reentrancy...\"\n\n**💡 Recommendation**: Review the contract manually, check the AI service configuration, or try the analysis again. The AI may have provided analysis in a non-standard format.\n\n---\n\n\n*Report generated on 7/26/2025, 6:01:32 PM*\n",
      "findings_count": 1,
      "critical_findings": 0,
      "high_findings": 0,
      "medium_findings": 0,
      "low_findings": 1,
      "audit_status": "completed",
      "created_at": "2025-07-26T16:01:32.491Z",
      "updated_at": "2025-07-26T16:01:32.491Z",
      "processing_time_ms": 27414,
      "error_message": null,
      "audit_engine_version": "1.0.0",
      "static_analysis_tools": "[\"AI Analysis\"]"
    },
    {
      "id": "report_1753551653509_479tk4rrp",
      "contract_address": "0x22f41abf77905f50df398f21213290597e7414dd",
      "report_json": "{\"findings\":[{\"id\":\"vuln-1\",\"category\":\"Reentrancy\",\"severity\":\"high\",\"swc_id\":\"SWC-107\",\"cwe_id\":\"CWE-362\",\"title\":\"Reentrancy Vulnerability in `_transfer` Function\",\"description\":\"The `_transfer` function performs state updates after an external call to `_afterTokenTransfer`, which could allow a malicious contract to repeatedly call `_transfer` before the state is updated, leading to reentrancy attacks.\",\"lines\":[231,232,233,234,235,236,237,238,239,240,241,242],\"codeSnippet\":\"function _transfer( address sender, address recipient, uint256 amount ) internal virtual { require(sender != address(0), \\\"ERC20: transfer from the zero address\\\"); require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\"); _beforeTokenTransfer(sender, recipient, amount); uint256 senderBalance = _balances[sender]; require( senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\" ); unchecked { _balances[sender] = senderBalance - amount; } _balances[recipient] += amount; emit Transfer(sender, recipient, amount); _afterTokenTransfer(sender, recipient, amount); }\",\"location\":\"_transfer function in ERC20 contract\",\"recommendation\":\"Implement the Checks-Effects-Interactions pattern by updating the state before the external call to `_afterTokenTransfer`. Additionally, consider using a reentrancy guard modifier to protect critical functions.\",\"accuracy\":0.2},{\"id\":\"vuln-2\",\"category\":\"Integer Overflow\",\"severity\":\"high\",\"swc_id\":\"SWC-101\",\"cwe_id\":\"CWE-integer-overflow-underflow\",\"title\":\"Potential Integer Overflow in `_mint` Function\",\"description\":\"The `_mint` function does not perform any overflow checks when adding the `amount` to the `_totalSupply` and `_balances[account]`. This could lead to integer overflow vulnerabilities, allowing an attacker to mint an arbitrary amount of tokens.\",\"lines\":[259,260,261],\"codeSnippet\":\"function _mint(address account, uint256 amount) internal virtual { require(account != address(0), \\\"ERC20: mint to the zero address\\\"); _beforeTokenTransfer(address(0), account, amount); _totalSupply += amount; _balances[account] += amount; emit Transfer(address(0), account, amount); _afterTokenTransfer(address(0), account, amount); }\",\"location\":\"_mint function in ERC20 contract\",\"recommendation\":\"Use OpenZeppelin's SafeMath library or Solidity 0.8+ checked arithmetic to prevent integer overflow vulnerabilities.\",\"accuracy\":0.6000000000000001},{\"id\":\"vuln-3\",\"category\":\"Unprotected Ether Withdrawal\",\"severity\":\"high\",\"swc_id\":\"SWC-105\",\"cwe_id\":\"CWE-284\",\"title\":\"Unprotected Ether Withdrawal in `burn` Function\",\"description\":\"The `burn` function allows any user to burn their own tokens, but it does not have any access control mechanism to prevent unauthorized withdrawal of the contract's Ether balance.\",\"lines\":[288],\"codeSnippet\":\"function burn(uint256 _amount) external { _burn(msg.sender, _amount); }\",\"location\":\"burn function in PPIToken contract\",\"recommendation\":\"Add an access control modifier, such as `onlyOwner`, to the `burn` function to restrict its usage to authorized entities only.\",\"accuracy\":0}],\"categorizedFindings\":{\"security\":[{\"id\":\"vuln-1\",\"category\":\"Reentrancy\",\"severity\":\"high\",\"swc_id\":\"SWC-107\",\"cwe_id\":\"CWE-362\",\"title\":\"Reentrancy Vulnerability in `_transfer` Function\",\"description\":\"The `_transfer` function performs state updates after an external call to `_afterTokenTransfer`, which could allow a malicious contract to repeatedly call `_transfer` before the state is updated, leading to reentrancy attacks.\",\"lines\":[231,232,233,234,235,236,237,238,239,240,241,242],\"codeSnippet\":\"function _transfer( address sender, address recipient, uint256 amount ) internal virtual { require(sender != address(0), \\\"ERC20: transfer from the zero address\\\"); require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\"); _beforeTokenTransfer(sender, recipient, amount); uint256 senderBalance = _balances[sender]; require( senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\" ); unchecked { _balances[sender] = senderBalance - amount; } _balances[recipient] += amount; emit Transfer(sender, recipient, amount); _afterTokenTransfer(sender, recipient, amount); }\",\"location\":\"_transfer function in ERC20 contract\",\"recommendation\":\"Implement the Checks-Effects-Interactions pattern by updating the state before the external call to `_afterTokenTransfer`. Additionally, consider using a reentrancy guard modifier to protect critical functions.\",\"accuracy\":0.2},{\"id\":\"vuln-2\",\"category\":\"Integer Overflow\",\"severity\":\"high\",\"swc_id\":\"SWC-101\",\"cwe_id\":\"CWE-integer-overflow-underflow\",\"title\":\"Potential Integer Overflow in `_mint` Function\",\"description\":\"The `_mint` function does not perform any overflow checks when adding the `amount` to the `_totalSupply` and `_balances[account]`. This could lead to integer overflow vulnerabilities, allowing an attacker to mint an arbitrary amount of tokens.\",\"lines\":[259,260,261],\"codeSnippet\":\"function _mint(address account, uint256 amount) internal virtual { require(account != address(0), \\\"ERC20: mint to the zero address\\\"); _beforeTokenTransfer(address(0), account, amount); _totalSupply += amount; _balances[account] += amount; emit Transfer(address(0), account, amount); _afterTokenTransfer(address(0), account, amount); }\",\"location\":\"_mint function in ERC20 contract\",\"recommendation\":\"Use OpenZeppelin's SafeMath library or Solidity 0.8+ checked arithmetic to prevent integer overflow vulnerabilities.\",\"accuracy\":0.6000000000000001},{\"id\":\"vuln-3\",\"category\":\"Unprotected Ether Withdrawal\",\"severity\":\"high\",\"swc_id\":\"SWC-105\",\"cwe_id\":\"CWE-284\",\"title\":\"Unprotected Ether Withdrawal in `burn` Function\",\"description\":\"The `burn` function allows any user to burn their own tokens, but it does not have any access control mechanism to prevent unauthorized withdrawal of the contract's Ether balance.\",\"lines\":[288],\"codeSnippet\":\"function burn(uint256 _amount) external { _burn(msg.sender, _amount); }\",\"location\":\"burn function in PPIToken contract\",\"recommendation\":\"Add an access control modifier, such as `onlyOwner`, to the `burn` function to restrict its usage to authorized entities only.\",\"accuracy\":0}],\"gas_optimization\":[],\"code_quality\":[],\"other\":[]},\"summary\":{\"total\":3,\"critical\":0,\"high\":3,\"medium\":0,\"low\":0,\"byCategory\":{\"security\":3,\"gas_optimization\":0,\"code_quality\":0,\"other\":0}},\"generatedAt\":\"2025-07-26T17:40:53.495Z\"}",
      "report_markdown": "# Smart Contract Audit Report\n\n## Executive Summary\n\n**Total Findings**: 3\n\n### Severity Distribution\n- **Critical**: 0 🔴\n- **High**: 3 🟠\n- **Medium**: 0 🟡\n- **Low**: 0 🟢\n\n### Category Distribution\n- **Security Issues**: 3 findings\n- **Gas Optimization**: 0 findings\n- **Code Quality**: 0 findings\n- **Other Issues**: 0 findings\n\n---\n\n## 🔒 Security Issues\n\nFound 3 issues in this category.\n\n### 1. Reentrancy Vulnerability in `_transfer` Function 🟠\n\n**Category**: Reentrancy  \n**Severity**: HIGH\n\n**Description**: The `_transfer` function performs state updates after an external call to `_afterTokenTransfer`, which could allow a malicious contract to repeatedly call `_transfer` before the state is updated, leading to reentrancy attacks.\n\n**Standards**: SWC-107, CWE-362\n\n**Location**: _transfer function in ERC20 contract\n\n**Affected Lines**: 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242\n\n**💡 Recommendation**: Implement the Checks-Effects-Interactions pattern by updating the state before the external call to `_afterTokenTransfer`. Additionally, consider using a reentrancy guard modifier to protect critical functions.\n\n---\n\n### 2. Potential Integer Overflow in `_mint` Function 🟠\n\n**Category**: Integer Overflow  \n**Severity**: HIGH\n\n**Description**: The `_mint` function does not perform any overflow checks when adding the `amount` to the `_totalSupply` and `_balances[account]`. This could lead to integer overflow vulnerabilities, allowing an attacker to mint an arbitrary amount of tokens.\n\n**Standards**: SWC-101, CWE-integer-overflow-underflow\n\n**Location**: _mint function in ERC20 contract\n\n**Affected Lines**: 259, 260, 261\n\n**💡 Recommendation**: Use OpenZeppelin's SafeMath library or Solidity 0.8+ checked arithmetic to prevent integer overflow vulnerabilities.\n\n---\n\n### 3. Unprotected Ether Withdrawal in `burn` Function 🟠\n\n**Category**: Unprotected Ether Withdrawal  \n**Severity**: HIGH\n\n**Description**: The `burn` function allows any user to burn their own tokens, but it does not have any access control mechanism to prevent unauthorized withdrawal of the contract's Ether balance.\n\n**Standards**: SWC-105, CWE-284\n\n**Location**: burn function in PPIToken contract\n\n**Affected Lines**: 288\n\n**💡 Recommendation**: Add an access control modifier, such as `onlyOwner`, to the `burn` function to restrict its usage to authorized entities only.\n\n---\n\n\n*Report generated on 7/26/2025, 7:40:53 PM*\n",
      "findings_count": 3,
      "critical_findings": 0,
      "high_findings": 3,
      "medium_findings": 0,
      "low_findings": 0,
      "audit_status": "completed",
      "created_at": "2025-07-26T17:40:53.509Z",
      "updated_at": "2025-07-26T17:40:53.509Z",
      "processing_time_ms": 10298,
      "error_message": null,
      "audit_engine_version": "1.0.0",
      "static_analysis_tools": "[\"AI Analysis\"]"
    },
    {
      "id": "report_1753570076850_r65cy166n",
      "contract_address": "0x22f41abf77905f50df398f21213290597e7414dd",
      "report_json": "{\"findings\":[{\"id\":\"vuln-1\",\"category\":\"Reentrancy\",\"severity\":\"high\",\"swc_id\":\"SWC-107\",\"cwe_id\":\"CWE-362\",\"title\":\"Reentrancy Vulnerability in `_transfer` Function\",\"description\":\"The `_transfer` function updates the balance of the sender before making an external call to the recipient. This could allow a malicious contract to repeatedly call `_transfer` before the balance is updated, leading to a reentrancy attack.\",\"lines\":[206,207,208,209,210,211,212,213,214],\"codeSnippet\":\"function _transfer( address sender, address recipient, uint256 amount ) internal virtual { require(sender != address(0), \\\"ERC20: transfer from the zero address\\\"); require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\"); _beforeTokenTransfer(sender, recipient, amount); uint256 senderBalance = _balances[sender]; require( senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\" ); unchecked { _balances[sender] = senderBalance - amount; } _balances[recipient] += amount; emit Transfer(sender, recipient, amount); _afterTokenTransfer(sender, recipient, amount); }\",\"location\":\"_transfer function in ERC20 contract\",\"recommendation\":\"Implement the Checks-Effects-Interactions pattern by updating the balance of the sender after the external call to the recipient. Additionally, consider using a reentrancy guard modifier to protect critical functions.\",\"accuracy\":0.30000000000000004},{\"id\":\"vuln-2\",\"category\":\"Integer Overflow\",\"severity\":\"high\",\"swc_id\":\"SWC-101\",\"cwe_id\":\"CWE-integer-overflow-underflow\",\"title\":\"Potential Integer Overflow in `_mint` Function\",\"description\":\"The `_mint` function does not perform any overflow checks when adding the `amount` to the `_totalSupply` and the recipient's balance. This could allow an attacker to mint an arbitrary number of tokens, leading to an integer overflow vulnerability.\",\"lines\":[248,249,250],\"codeSnippet\":\"function _mint(address account, uint256 amount) internal virtual { require(account != address(0), \\\"ERC20: mint to the zero address\\\"); _beforeTokenTransfer(address(0), account, amount); _totalSupply += amount; _balances[account] += amount; emit Transfer(address(0), account, amount); _afterTokenTransfer(address(0), account, amount); }\",\"location\":\"_mint function in ERC20 contract\",\"recommendation\":\"Implement SafeMath or Solidity 0.8+ overflow checks to prevent integer overflow vulnerabilities.\",\"accuracy\":0},{\"id\":\"vuln-3\",\"category\":\"Unprotected Ether Withdrawal\",\"severity\":\"high\",\"swc_id\":\"SWC-105\",\"cwe_id\":\"CWE-284\",\"title\":\"Unprotected Ether Withdrawal in `burn` Function\",\"description\":\"The `burn` function allows any user to burn their own tokens, but it does not have any access control mechanism to prevent unauthorized withdrawal of contract funds. This could allow an attacker to drain the contract's Ether balance.\",\"lines\":[288],\"codeSnippet\":\"function burn(uint256 _amount) external { _burn(msg.sender, _amount); }\",\"location\":\"burn function in PPIToken contract\",\"recommendation\":\"Add an access control modifier, such as `onlyOwner`, to the `burn` function to restrict its usage to authorized entities only.\",\"accuracy\":0}],\"categorizedFindings\":{\"security\":[{\"id\":\"vuln-1\",\"category\":\"Reentrancy\",\"severity\":\"high\",\"swc_id\":\"SWC-107\",\"cwe_id\":\"CWE-362\",\"title\":\"Reentrancy Vulnerability in `_transfer` Function\",\"description\":\"The `_transfer` function updates the balance of the sender before making an external call to the recipient. This could allow a malicious contract to repeatedly call `_transfer` before the balance is updated, leading to a reentrancy attack.\",\"lines\":[206,207,208,209,210,211,212,213,214],\"codeSnippet\":\"function _transfer( address sender, address recipient, uint256 amount ) internal virtual { require(sender != address(0), \\\"ERC20: transfer from the zero address\\\"); require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\"); _beforeTokenTransfer(sender, recipient, amount); uint256 senderBalance = _balances[sender]; require( senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\" ); unchecked { _balances[sender] = senderBalance - amount; } _balances[recipient] += amount; emit Transfer(sender, recipient, amount); _afterTokenTransfer(sender, recipient, amount); }\",\"location\":\"_transfer function in ERC20 contract\",\"recommendation\":\"Implement the Checks-Effects-Interactions pattern by updating the balance of the sender after the external call to the recipient. Additionally, consider using a reentrancy guard modifier to protect critical functions.\",\"accuracy\":0.30000000000000004},{\"id\":\"vuln-2\",\"category\":\"Integer Overflow\",\"severity\":\"high\",\"swc_id\":\"SWC-101\",\"cwe_id\":\"CWE-integer-overflow-underflow\",\"title\":\"Potential Integer Overflow in `_mint` Function\",\"description\":\"The `_mint` function does not perform any overflow checks when adding the `amount` to the `_totalSupply` and the recipient's balance. This could allow an attacker to mint an arbitrary number of tokens, leading to an integer overflow vulnerability.\",\"lines\":[248,249,250],\"codeSnippet\":\"function _mint(address account, uint256 amount) internal virtual { require(account != address(0), \\\"ERC20: mint to the zero address\\\"); _beforeTokenTransfer(address(0), account, amount); _totalSupply += amount; _balances[account] += amount; emit Transfer(address(0), account, amount); _afterTokenTransfer(address(0), account, amount); }\",\"location\":\"_mint function in ERC20 contract\",\"recommendation\":\"Implement SafeMath or Solidity 0.8+ overflow checks to prevent integer overflow vulnerabilities.\",\"accuracy\":0},{\"id\":\"vuln-3\",\"category\":\"Unprotected Ether Withdrawal\",\"severity\":\"high\",\"swc_id\":\"SWC-105\",\"cwe_id\":\"CWE-284\",\"title\":\"Unprotected Ether Withdrawal in `burn` Function\",\"description\":\"The `burn` function allows any user to burn their own tokens, but it does not have any access control mechanism to prevent unauthorized withdrawal of contract funds. This could allow an attacker to drain the contract's Ether balance.\",\"lines\":[288],\"codeSnippet\":\"function burn(uint256 _amount) external { _burn(msg.sender, _amount); }\",\"location\":\"burn function in PPIToken contract\",\"recommendation\":\"Add an access control modifier, such as `onlyOwner`, to the `burn` function to restrict its usage to authorized entities only.\",\"accuracy\":0}],\"gas_optimization\":[],\"code_quality\":[],\"other\":[]},\"summary\":{\"total\":3,\"critical\":0,\"high\":3,\"medium\":0,\"low\":0,\"byCategory\":{\"security\":3,\"gas_optimization\":0,\"code_quality\":0,\"other\":0}},\"generatedAt\":\"2025-07-26T22:47:56.833Z\"}",
      "report_markdown": "# Smart Contract Audit Report\n\n## Executive Summary\n\n**Total Findings**: 3\n\n### Severity Distribution\n- **Critical**: 0 🔴\n- **High**: 3 🟠\n- **Medium**: 0 🟡\n- **Low**: 0 🟢\n\n### Category Distribution\n- **Security Issues**: 3 findings\n- **Gas Optimization**: 0 findings\n- **Code Quality**: 0 findings\n- **Other Issues**: 0 findings\n\n---\n\n## 🔒 Security Issues\n\nFound 3 issues in this category.\n\n### 1. Reentrancy Vulnerability in `_transfer` Function 🟠\n\n**Category**: Reentrancy  \n**Severity**: HIGH\n\n**Description**: The `_transfer` function updates the balance of the sender before making an external call to the recipient. This could allow a malicious contract to repeatedly call `_transfer` before the balance is updated, leading to a reentrancy attack.\n\n**Standards**: SWC-107, CWE-362\n\n**Location**: _transfer function in ERC20 contract\n\n**Affected Lines**: 206, 207, 208, 209, 210, 211, 212, 213, 214\n\n**💡 Recommendation**: Implement the Checks-Effects-Interactions pattern by updating the balance of the sender after the external call to the recipient. Additionally, consider using a reentrancy guard modifier to protect critical functions.\n\n---\n\n### 2. Potential Integer Overflow in `_mint` Function 🟠\n\n**Category**: Integer Overflow  \n**Severity**: HIGH\n\n**Description**: The `_mint` function does not perform any overflow checks when adding the `amount` to the `_totalSupply` and the recipient's balance. This could allow an attacker to mint an arbitrary number of tokens, leading to an integer overflow vulnerability.\n\n**Standards**: SWC-101, CWE-integer-overflow-underflow\n\n**Location**: _mint function in ERC20 contract\n\n**Affected Lines**: 248, 249, 250\n\n**💡 Recommendation**: Implement SafeMath or Solidity 0.8+ overflow checks to prevent integer overflow vulnerabilities.\n\n---\n\n### 3. Unprotected Ether Withdrawal in `burn` Function 🟠\n\n**Category**: Unprotected Ether Withdrawal  \n**Severity**: HIGH\n\n**Description**: The `burn` function allows any user to burn their own tokens, but it does not have any access control mechanism to prevent unauthorized withdrawal of contract funds. This could allow an attacker to drain the contract's Ether balance.\n\n**Standards**: SWC-105, CWE-284\n\n**Location**: burn function in PPIToken contract\n\n**Affected Lines**: 288\n\n**💡 Recommendation**: Add an access control modifier, such as `onlyOwner`, to the `burn` function to restrict its usage to authorized entities only.\n\n---\n\n\n*Report generated on 7/27/2025, 12:47:56 AM*\n",
      "findings_count": 3,
      "critical_findings": 0,
      "high_findings": 3,
      "medium_findings": 0,
      "low_findings": 0,
      "audit_status": "completed",
      "created_at": "2025-07-26T22:47:56.850Z",
      "updated_at": "2025-07-26T22:47:56.850Z",
      "processing_time_ms": 8515,
      "error_message": null,
      "audit_engine_version": "1.0.0",
      "static_analysis_tools": "[\"AI Analysis\"]"
    }
  ],
  "webhook_configurations": [],
  "webhook_deliveries": []
}